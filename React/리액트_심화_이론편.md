# 이론편

## 자바스크립트

### 변수

선언 → 초기화 → 할당 과정을 거친다.

선언 : 스코프가 참조하는 대상이 되도록 실행 컨텍스트에 변수 객체를 등록하는 과정

초기화 : 실제 메모리 공간을 확보하는 행위

var는 사용하지 말자. → block scope 무시, 호이스팅 단계에서 선언과 초기화를 동시에 하기 때문에 선언 이전에 호출이 가

let, const도 호이스팅을 하지만 초기화 없이 선언만 하기 때문에 변수 이전에 호출하면 레퍼런스 에러를 내준다. → 변수를 참조할 수 없는 일시적 사각지대(TDZ)

### 엄격 모드

자바스크립트는 기본적으로 모던한 방식보다는 하위 호환에 초점을 맞추어 동작하기 때문에 최신 기능을 사용할 때는 `'use strict;'` 를 스크립트 최상단에 써준다.

### 상수의 재할당

const로 선언된 객체는 객체에 대한 참조를 변경하지 못할 뿐 객체의 프로퍼티는 보호되지 않는다.

### 함수

함수 선언문 : 전체가 호이스팅의 대상이 된다.

함수 표현식(화살표 함수 포함) : 변수 선언부만 호이스팅된다.

### 프로토타입

자바스크립트는 클래스 없이 리터럴이나 생성자를 사용하여 객체를 생성한다.

자바스크립트의 모든 객체는 자신의 부모 객체(의 원형)와 연결되어 있다.

→ 부모 객체의 프로퍼티나 메소드를 위임받아 사용할 수 있다.

→ 부모 객체를 참조하는 걸 "프로토타입 링크"라고 부른다.

`[[Prototype]]` (숨김 프로퍼티)가 참조하는 값과 `__proto__` ???

`__proto__` 는 deprecated 되었기 때문에

`Object.getPrototypeOf()`를 이용해 참조하고,

프로토타입 체인에 연결할 때는  `Object.create()` 를 이용한다.

### Promise

자바스크립트는 싱글 쓰레드로 동작한다. 즉, 일꾼이 한 사람이다.

하지만 코어 엔진 이외에 실행환경(런타임)의 도움을 받아서 비동기 작업을 동시에 할 수 있다.

프라미스란 비동기 연산이 종료된 이후 결과를 알기 위해 사용되는 객체다.

→ 비동기 처리 시점을 좀 더 명확하게 표현할 수 있다.

```tsx
// 프라미스 객체를 만듭니다. 
// 인자로는 (resolve, reject) => {} 이런 excutor 실행자(혹은 실행 함수라고 불러요.)를 받아요.
// 이 실행자는 비동기 작업이 끝나면 바로 두 가지 콜백 중 하나를 실행합니다.
// resolve: 작업이 성공한 경우 호출할 콜백
// reject: 작업이 실패한 경우 호출할 콜백
const promise = new Promise((resolve, reject) => {
	if(...){
		...
		resolve("성공!");
	}else{
		...
		reject("실패!");
	}
});
```

프라미스의 상태 값으로는 pending(처리 중), fulfilled(성공, resolve 호출), reject(실패, reject 호출), settled(완료)가 있다.

프라미스로 구현된 비동기 함수는 프라미스 객체를 반환하며, 이 프라미스 객체의 후속 처리 메서드를 통해 비동기 처리 결과를 받아서 처리해야 한다.

- then : 첫 인자는 성공시 실행, 두번째 인자는 실패 시 실행된다.

    ```tsx
    // 프라미스를 하나 만들어 봅시다!
    let promise = new Promise((resolve, reject) => {
    	setTimeout(() => resolve("완료!"), 1000);
    });

    // resolve
    promise.then(result => {
    	console.log(result); // 완료!가 콘솔에 찍힐거예요.
    }, error => {
    	console.log(error); // 실행되지 않습니다.
    });
    ```

- catch : 실패 시 실행

    ```tsx
    // 프라미스를 하나 만들어 봅시다!
    let promise = new Promise((resolve, reject) => {
    	setTimeout(() => reject(new Error("오류!"), 1000);
    });

    promise.catch((error) => {console.log(error};);
    ```

후속 처리 메서드를 체이닝해서 여러 개의 프라미스를 연결할 수도 있다. 이걸로 콜백 헬을 해결할 수 있다.

### async, await

프라미스 사용을 더 편하게 만들어준다. → 추가적으로 제너레이터와 이터러블을 공부하자 😆

함수 앞에 async를 붙이면 항상 프라미스를 반환해준다.

```tsx
// async는 function 앞에 써줍니다.
async function myFunc() {
	return "프라미스를 반환해요!"; // 프라미스가 아닌 걸 반환해볼게요!
}

myFunc().then(result => {console.log(result)}); // 콘솔로 확인해봅시다!
```

await은 async 함수 안에서만 동작하며, 프라미스가 처리될 때까지 기다렸다가 그 이후에 결과를 반환한다.

## 프로젝트 세팅

### 기획서 쪼개기

- 프로토타입 툴로는 "[피그마](https://www.figma.com/file/5GhEvvI68oIM7xOm6p3mIO/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0?node-id=1%3A2)"를 사용한다.
- 컴포넌트는 "재사용성"을 생각하여 쪼갠다.

    → 페이지마다 반복되는 부분 찾기

- 폴더 구조를 잡는다.
    - `public` : 가상 돔이 들어갈 빈 껍데기 index.html이 들어있다.
    - `src`
        - `elements` : 최소단위 컴포넌트(input, button...)
        - `components` : 최소단위 컴포넌트를 조합해서 만든 중간단위 컴포넌트
        - `pages` : 페이지 시작점, 중간단위 컴포넌트를 조합하여 페이지를 구성한다.
        - `redux` : 리덕스 모듈과 스토어가 들어간다.
        - `shared` : 공용으로 사용할 코드 (App.js 포함)
- 페이지부터 만들기
- 라우터 잡아주기

    ```tsx
    import './App.css';
    import React from "react";

    import {BrowserRouter, Route} from "react-router-dom";
    import PostList from "../pages/PostList";

    function App() {
      return (
        <React.Fragment>
          <BrowserRouter>
            <Route path="/" exact component={PostList}/>
          </BrowserRouter>
        </React.Fragment>
      );
    }

    export default App;
    ```

- 페이지에 들어갈 내용을 크게 쪼개서 컴포넌트 만들기

    → 페이지를 그리는데 꼭 필요한 데이터를 defaultProps에 담아두면 데이터가 없어서 나는 오류를 방지할 수 있다.

- Grid 잡기

    ```tsx
    import React from "react";
    import styled from "styled-components";

    const Grid = (props) => {
      const { is_flex, width, margin, padding, bg, children } = props;

      const styles = {
          is_flex: is_flex,
          width: width,
          margin: margin,
          padding: padding,
          bg: bg,
      };
      return (
        <React.Fragment>
          <GridBox {...styles}>{children}</GridBox>
        </React.Fragment>
      );
    };

    Grid.defaultProps = {
      chidren: null,
      is_flex: false,
      width: "100%",
      padding: false,
      margin: false,
      bg: false,
    };

    const GridBox = styled.div`
      width: ${(props) => props.width};
      height: 100%;
      box-sizing: border-box;
      ${(props) => (props.padding ? `padding: ${props.padding};` : "")}
      ${(props) => (props.margin ? `margin: ${props.margin};` : "")}
      ${(props) => (props.bg ? `background-color: ${props.bg};` : "")}
      ${(props) =>
        props.is_flex
          ? `display: flex; align-items: center; justify-content: space-between; `
          : ""}
    `;

    export default Grid;
    ```

- 최소단위 컴포넌트 만들기 : Grid, Image, Text

    → `elements/index.js` 를 만들어두면 import가 훨씬 깔끔해진다.

    ```tsx
    // elements/index.js
    import Grid from "./Grid";
    import Image from "./Image"
    import Text from "./Text";

    export {Grid, Image, Text};

    // 불러오는 곳
    import {Grid, Image, Text} from "../elements";
    ```

## 토큰 기반 인증

예전에는 서버의 세션에 사용자 정보를 넣고 로그인 여부를 전부 기록하고 기억했다.

→ 로그인 사용자가 많아지면 서버에 부하가 간다. 그래서 요즘에는 토큰 기반 인증 방법을 많이 사용한다.

### OAuth2.0

Open Authentication, Open Authorization(인증과 허가)

외부서비스의 인증 및 권한부여를 관리하는 프레임워크

**간단한 동작 방식**

클라이언트와 서버 사이에 로그인 인증을 하면 서버가 `access_token` 을 주고, 클라이언트는 `access_token` 을 이용해서 API 요청을 할 수 있다.

서버는 API 요청을 받고, `access_token`을 가지고 권한이 있는지 없는지를 확인해서 결과를 클라이언트에 보내준다.

**외부 서비스가 엮인 경우의 동작 방식(feat. 구글 로그인)**

구글이 유저 정보도 가지고 있고, 로그인 검증도 해준다. 즉, 자원 서버 + 권한 서버의 역할을 한다.

1. 유저가 구글 로그인 : 구글 자원서버에 권한을 요청한다.
2. 구글이 유저가 입력한 정보를 보고 서버에 접근 권한을 준다.
3. 서버는 이 권한으로 구글 권한서버에 `access_token`을 요청한다.
4. 서버는 이 `access_token`을 가지고 구글에서 유저 정보를 가져올 수 있다.
5. 구글은 서버가 보낸 `access_token`을 가지고 권한이 있는지 없는지 확인해서 결과를 서버에게 보내준다.

### JWT

JSON Web Token, 토큰의 한 형식이다.

**[header].[payload].[signature]**

유저가 로그인을 시도하면, 서버가 secret key를 가지고 `access_token`을 발급한다.

클라이언트에 JWT를 전달하고, 클라이언트는 API 요청 시 Authorization header에 JWT를 담아보낸다.

서버는 JWT의 서명을 확인하고, payload에서 정보를 확인하여 API 응답을 보낸다.

## 웹 저장소

`access_token`을 저장하기 위해 클라이언트에서 쓸 수 있는 저장소

개발자 도구 → Application 탭 → Storage 확인

- 쿠키 : 4KB 정도 저장 가능, `document.cookie`

    → 쿠키 삭제 시에는 만료일을 이전으로 돌려서 지우는 방법을 사용

    ```tsx
    document.cookie = "MY_COOKIE=here; expires=new Date('2020-12-12').toUTCString()";
    ```

- 세션 스토리지 : 브라우저를 닫으면 저장된 데이터가 제거된다.

    ```tsx
    // key는 MY_SESSION, value는 here인 세션을 만들어요.
    sessionStorage.setItem("MY_SESSION", "here");

    // key값으로 쉽게 가져올 수 있어요 :) 
    sessionStorage.getItem("MY_SESSION");

    // 하나만 삭제하고 싶다면, 이렇게 키를 통해 삭제합니다.
    sessionStorage.removeItem("MY_SESSION");

    // 몽땅 지우고 싶을 땐 clear()를 쓰면 됩니다. :) 
    sessionStorage.clear();
    ```

- 로컬 스토리지 : 따로 지워주지 않으면 브라우저에 계속 남아있다.

    → 유저의 중요 정보를 넣어두면 위험하다.

    → 세션 스토리지와 사용법은 동일 `localStorage`

쿠키보다 로컬 스토리지에 저장하면 5MB로 더 많은 정보를 저장할 수 있다.

또한, 쿠키처럼 모든 http 통신에 딸려들어가지 않는다.

- 쿠키를 생성하고, 가져오고, 지우는 함수 만들기

    ```tsx
    // 키값 기준으로 쿠키에 저장된 값을 가져오는 함수
    const getCookie = (name) => {
      // 쿠키 값을 가져옵니다.
      let value = "; " + document.cookie;
      // 키 값을 기준으로 파싱합니다.
      let parts = value.split("; " + name + "=");
      // value를 return!
      if (parts.length === 2) {
    		return parts.pop().split(";").shift();
    	}
    };

    // 쿠키에 저장하는 함수
    const setCookie = (name, value, exp = 5) => {
      let date = new Date();
      // 날짜를 만들어줍니다.
      date.setTime(date.getTime() + exp * 24 * 60 * 60 * 1000);
      // 저장!
      document.cookie = `${name}=${value};expires=${date.toUTCString()};path=/`;
    };

    // 만료일을 예전으로 설정해 쿠키를 지웁니다.
    const deleteCookie = (name) => {
      document.cookie = name + '=; expires=Thu, 01 Jan 1999 00:00:10 GMT;';
    }

    export { getCookie, setCookie, deleteCookie };
    ```