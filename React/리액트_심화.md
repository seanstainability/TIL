# 리액트 심화반

[이론편](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA%E1%84%87%E1%85%A1%E1%86%AB%203919ac1335334519a0da4373744db222/%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%203e3e4429010e43fc8ff578353d24912e.md)

## Firebase Authentication

- 열어보기

    파이어베이스에서 제공하는 인증 기능으로 다양한 소셜 로그인과 파이어베이스에 직접 사용자를 추가하고 관리하는 기능을 제공한다.

    ![%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA%E1%84%87%E1%85%A1%E1%86%AB%203919ac1335334519a0da4373744db222/firebase-authentication.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA%E1%84%87%E1%85%A1%E1%86%AB%203919ac1335334519a0da4373744db222/firebase-authentication.png)

    ```jsx
    // shared/firebase.js
    import firebase from "firebase/app";
    import "firebase/auth";

    const firebaseConfig = {
    // 인증정보!
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();

    export { auth };
    ```

## 회원가입

- 사전 준비
    - firebase.js에서 auth 설정하기
    - Cookie.js에서 쿠키 생성, 가져오기, 삭제 하는 함수 만들기
- 리덕스 모듈 만들기

    ```jsx
    import { createAction, handleActions } from "redux-actions";
    import { produce } from "immer";

    import { setCookie, getCookie, deleteCookie } from "../../shared/Cookie";

    import { auth } from "../../shared/firebase";

    // actions
    const LOG_OUT = "LOG_OUT";
    const GET_USER = "GET_USER";
    const SET_USER = "SET_USER";

    // action creators
    const logOut = createAction(LOG_OUT, (user) => ({ user }));
    const getUser = createAction(GET_USER, (user) => ({ user }));
    const setUser = createAction(SET_USER, (user) => ({ user }));

    // initialState
    const initialState = {
      user: null,
      is_login: false,
    };

    // middleware actions
    const signupFB = (id, pwd, user_name) => {
      return function (dispatch, getState, {history}){

        auth
          .createUserWithEmailAndPassword(id, pwd)
          .then((user) => {

            console.log(user);
            
            auth.currentUser.updateProfile({
              displayName: user_name,
            }).then(()=>{
              dispatch(setUser({user_name: user_name, id: id, user_profile: ''}));
              history.push('/');
            }).catch((error) => {
              console.log(error);
            });

            // Signed in
            // ...
          })
          .catch((error) => {
            var errorCode = error.code;
            var errorMessage = error.message;

            console.log(errorCode, errorMessage);
            // ..
          });

      }
    }

    // reducer
    export default handleActions(
      {
        [SET_USER]: (state, action) =>
          produce(state, (draft) => {
            setCookie("is_login", "success");
            draft.user = action.payload.user;
            draft.is_login = true;
          }),
        [LOG_OUT]: (state, action) =>
          produce(state, (draft) => {
            deleteCookie("is_login");
            draft.user = null;
            draft.is_login = false;
          }),
        [GET_USER]: (state, action) => produce(state, (draft) => {}),
      },
      initialState
    );

    // action creator export
    const actionCreators = {
      logOut,
      getUser,
      signupFB,
    };

    export { actionCreators };
    ```

- 회원가입 페이지에서 호출하기
    - 이메일 체크 정규 표현식

        ```tsx
        // shared/common.js
        export const emailCheck = (email) => {
            let _reg = /^[0-9a-zA-Z]([-_.0-9a-zA-Z])*@[0-9a-zA-Z]([-_.0-9a-zA-z])*.([a-zA-Z])*/;

            return _reg.test(email);
        }
        ```

    ```jsx
    import React from "react";
    import { Grid, Text, Input, Button } from "../elements";

    import { useDispatch } from "react-redux";
    import { actionCreators as userActions } from "../redux/modules/user";
    import { emailCheck } from "../shared/common";

    const Signup = (props) => {
      const dispatch = useDispatch();

      const [id, setId] = React.useState("");
      const [pwd, setPwd] = React.useState("");
      const [pwd_check, setPwdCheck] = React.useState("");
      const [user_name, setUserName] = React.useState("");

      const signup = () => {
        if (id === "" || pwd === "" || user_name === "") {
          window.alert("아이디, 패스워드, 닉네임을 모두 입력해주세요!");
          return;
        }

        if(!emailCheck(id)){
          window.alert('이메일 형식이 맞지 않습니다!');
          return;
        }
        
        if (pwd !== pwd_check) {
          window.alert("패스워드와 패스워드 확인이 일치하지 않습니다!");
          return;
        }

        dispatch(userActions.signupFB(id, pwd, user_name));
      };
      return (
        <React.Fragment>
          <Grid padding="16px">
            <Text size="32px" bold>
              회원가입
            </Text>

            <Grid padding="16px 0px">
              <Input
                label="아이디"
                placeholder="아이디를 입력해주세요."
                _onChange={(e) => {
                  setId(e.target.value);
                }}
              />
            </Grid>

            <Grid padding="16px 0px">
              <Input
                label="닉네임"
                placeholder="닉네임을 입력해주세요."
                _onChange={(e) => {
                  setUserName(e.target.value);
                }}
              />
            </Grid>

            <Grid padding="16px 0px">
              <Input
                label="비밀번호"
                placeholder="비밀번호를 입력해주세요."
                _onChange={(e) => {
                  setPwd(e.target.value);
                }}
              />
            </Grid>

            <Grid padding="16px 0px">
              <Input
                label="비밀번호 확인"
                placeholder="비밀번호를 다시 입력해주세요."
                _onChange={(e) => {
                  setPwdCheck(e.target.value);
                }}
              />
            </Grid>

            <Button text="회원가입하기" _onClick={signup}></Button>
          </Grid>
        </React.Fragment>
      );
    };

    Signup.defaultProps = {};

    export default Signup;
    ```

## 로그인

클라이언트에서는 서버에 로그인 요청을 보내고, 응답을 받아서 토큰을 저장하면 끝이다.

- 로그인한 상태일 때 헤더 만들기
    - 쿠키가 있으면 로그인한 헤더 보여주기
    - 로그아웃에 쿠키 삭제 함수 넣어주기

    ```jsx
    import React from "react";
    import {Grid, Text, Button} from "../elements";
    import {getCookie, deleteCookie} from "../shared/Cookie";
    const Header = (props) => {

        const [is_login, setIsLogin] = React.useState(false);

        React.useEffect(() => {

            // 쿠키를 가져와요!
            let cookie = getCookie('쿠키 이름 넣기!');
            // 확인해봅시다!
            console.log(cookie);
            // 쿠키가 있으면?
            if(cookie){
                setIsLogin(true);
            }else{
                setIsLogin(false);
            }
        });

        if(is_login){
            return (
              <React.Fragment>
                <Grid is_flex padding="4px 16px">
                  <Grid>
                    <Text margin="0px" size="24px" bold>
                      헬로
                    </Text>
                  </Grid>

                  <Grid is_flex>
                    <Button text="내정보"></Button>
                    <Button text="알림"></Button>
                    <Button text="로그아웃" _onClick={() => {deleteCookie('login');}}></Button>
                  </Grid>
                </Grid>
              </React.Fragment>
            );
        }
        return (
            <React.Fragment>
                <Grid is_flex padding="4px 16px">
                    <Grid>
                        <Text margin="0px" size="24px" bold>헬로</Text>
                    </Grid>
                    
                    <Grid is_flex>
                        <Button text="로그인"></Button>
                        <Button text="회원가입"></Button>
                    </Grid>
                </Grid>
            </React.Fragment>
        )
    }

    Header.defaultProps = {}

    export default Header;
    ```

- 리덕스 설치하기

    매번 쿠키를 체크하는 것보다 로그인 상태를 리덕스에 저장하고 어떤 컴포넌트에서든 편하게 볼 수 있게 만든다.

    ```jsx
    # 이건 리덕스와 리덕스 모듈 내에서 경로 이동까지 하게 해줄 히스토리, 라우터와 히스토리를 엮어줄 모듈까지 한번에 설치해보는 거예요.
    yarn add redux react-redux redux-thunk redux-logger history@4.10.1 connected-react-router@6.8.0
    ```

    ```jsx
    # 프론트엔드의 꽃 리액트 강의에서는 리듀서에서 뭔가를 바꿀 때 불변성 관리를 우리가 신경썼죠.
    # 이번엔 우리가 신경쓰지 말고, 임머라는 패키지 사용해서 해볼거예요.
    # 그리고 액션도 매번 맨 위에서 user/CREATE처럼 리듀서 모듈 명에 어떤 타입 넣어서 만들고, 
    # 그 아래에는 액션 생성 함수 만들어서 export 다 해주고 좀 귀찮았죠.
    # 이걸 redux-actions라는 패키지로 좀 더 편하게 쓸거예요.
    yarn add immer redux-actions
    ```

- 유저 모듈 만들기
    - import
    - 액션 타입
    - 액션 생성 함수
    - initialState
    - 리듀서
    - 액션 생성 함수 export
- 리덕스 스토어 만들기

    redux의 `combineReducers()`를 사용하여 export한 reducer를 모아 root reducer를 만든다.

    미들웨어를 적용해주고, root reducer와 미들웨어를 엮어 redux의 `createStore()`로 스토어를 만든다.

    ```jsx
    import { createStore, combineReducers, applyMiddleware, compose } from "redux";
    import thunk from "redux-thunk";
    import { createBrowserHistory } from "history";
    import { connectRouter } from "connected-react-router";

    import User from "./modules/user";

    export const history = createBrowserHistory();

    const rootReducer = combineReducers({
      user: User,
      router: connectRouter(history), // 스토어에 히스토리 넣어주기
    });

    // 미들웨어 준비
    // const middlewares = [thunk];
    const middlewares = [thunk.withExtraArgument({history: history})];

    // 지금이 어느 환경인 지 알려줘요. (개발환경, 프로덕션(배포)환경 ...)
    const env = process.env.NODE_ENV;

    // 개발환경에서는 로거라는 걸 하나만 더 써볼게요.
    if (env === "development") {
      const { logger } = require("redux-logger");
      middlewares.push(logger);
    }

    // redux devTools 설정
    const composeEnhancers =
      typeof window === "object" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
        ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
            // Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize...
          })
        : compose;

    // 미들웨어 묶기
    const enhancer = composeEnhancers(
      applyMiddleware(...middlewares)
    );

    // 미들웨어와 루트 리듀서를 엮어 스토어 만들기
    let store = (initialStore) => createStore(rootReducer, enhancer);

    export default store();
    ```

- 스토어 주입하기

    `Provider`를 `index.js`에서 주입하고, `App.js`에서 원래 `BrowserRouter`와 `Route`를 써서 컴포넌트에 주입하던 `history`를 `ConnectedRouter`를 써서 리덕스랑 같은 history를 사용하도록 해준다.

    ```jsx
    // index.js
    ...
    import store from "./redux/configureStore";
    import { Provider } from "react-redux";

    ReactDOM.render(
      <Provider store={store}>
        <App />
      </Provider>,
      document.getElementById("root")
    );
    ...
    ```

    ```jsx
    // App.js
    ...
    import { ConnectedRouter } from "connected-react-router";
    import { history } from "../redux/configureStore";
    ...
    function App() {
      return (
        <React.Fragment>
          <Grid>
            <Header></Header>
            <ConnectedRouter history={history}>
              <Route path="/" exact component={PostList} />
              <Route path="/login" exact component={Login} />
              <Route path="/signup" exact component={Signup}/>
            </ConnectedRouter>
          </Grid>
        </React.Fragment>
      );
    }
    ...
    ```

- 로그인 액션 실행하기

    ```jsx
    import React from "react";
    import { Text, Input, Grid, Button } from "../elements";
    import { getCookie, setCookie, deleteCookie } from "../shared/Cookie";

    import { useDispatch } from "react-redux";
    import { actionCreators as userActions } from "../redux/modules/user";

    const Login = (props) => {
      const dispatch = useDispatch();

      const [id, setId] = React.useState("");
      const [pwd, setPwd] = React.useState("");

      const login = () => {
        if(id === "" || pwd === ""){
          window.alert("아이디 혹은 비밀번호가 공란입니다! 입력해주세요!");
          return;
        }

        dispatch(userActions.loginFB(id, pwd));
      };

      return (
        <React.Fragment>
          <Grid padding="16px">
            <Text size="32px" bold>
              로그인
            </Text>

            <Grid padding="16px 0px">
              <Input
                label="아이디"
                placeholder="아이디를 입력해주세요."
                _onChange={(e) => {
                  setId(e.target.value);
                }}
              />
            </Grid>

            <Grid padding="16px 0px">
              <Input
                label="패스워드"
                placeholder="패스워드 입력해주세요."
                type="password"
                _onChange={(e) => {
                  setPwd(e.target.value);
                }}
              />
            </Grid>

            <Button
              text="로그인하기"
              _onClick={() => {
                console.log("로그인 했어!");
                login();
              }}
            ></Button>
          </Grid>
        </React.Fragment>
      );
    };

    export default Login;
    ```

- 리덕스에서 `auth.signInWithEmailAndPassword()`로 로그인 하는 함수 만들기

    ```jsx
    import { createAction, handleActions } from "redux-actions";
    import { produce } from "immer";

    import { setCookie, getCookie, deleteCookie } from "../../shared/Cookie";

    import { auth } from "../../shared/firebase";
    import firebase from "firebase/app";

    // actions
    const LOG_OUT = "LOG_OUT";
    const GET_USER = "GET_USER";
    const SET_USER = "SET_USER";

    // action creators
    const logOut = createAction(LOG_OUT, (user) => ({ user }));
    const getUser = createAction(GET_USER, (user) => ({ user }));
    const setUser = createAction(SET_USER, (user) => ({ user }));

    // initialState
    const initialState = {
      user: null,
      is_login: false,
    };

    // middleware actions
    const loginFB = (id, pwd) => {
      return function (dispatch, getState, { history }) {
        auth.setPersistence(firebase.auth.Auth.Persistence.SESSION).then((res) => {
          auth
            .signInWithEmailAndPassword(id, pwd)
            .then((user) => {
              console.log(user);

              dispatch(
                setUser({
                  user_name: user.user.displayName,
                  id: id,
                  user_profile: "",
                  uid: user.user.uid,
                })
              );

              history.push("/");
            })
            .catch((error) => {
              var errorCode = error.code;
              var errorMessage = error.message;

              console.log(errorCode, errorMessage);
            });
        });
      };
    };

    const loginCheckFB = () => {
      return function (dispatch, getState, {history}){
        auth.onAuthStateChanged((user) => {
          if(user){
            dispatch(
              setUser({
                user_name: user.displayName,
                user_profile: "",
                id: user.email,
                uid: user.uid,
              })
            );
          }else{
            dispatch(logOut());
          }
        })
      }
    }

    // 파이어베이스 인증에서 제공하는 로그아웃 함수 하나만 호출하면 끝!
    const logoutFB = () => {
      return function (dispatch, getState, {history}) {
        auth.signOut().then(() => {
          dispatch(logOut());
          history.replace('/');
        })
      }
    }

    // reducer
    export default handleActions(
      {
        [SET_USER]: (state, action) =>
          produce(state, (draft) => {
            setCookie("is_login", "success");
            draft.user = action.payload.user;
            draft.is_login = true;
          }),
        [LOG_OUT]: (state, action) =>
          produce(state, (draft) => {
            deleteCookie("is_login");
            draft.user = null;
            draft.is_login = false;
          }),
        [GET_USER]: (state, action) => produce(state, (draft) => {}),
      },
      initialState
    );

    // action creator export
    const actionCreators = {
      logOut,
      getUser,
      signupFB,
      loginFB,
      loginCheckFB,
      logoutFB,
    };

    export { actionCreators };
    ```

## 로그인 유지

쿠키에 로그인 유무를 저장하지 않고, firebase의 auth를 통해 관리한다.

- 로그인 시, 세션에 로그인 상태를 기록하도록 한다.

    ```tsx
    //user.js
    ...
    import firebase from "firebase/app";
    ...
    const loginFB = (id, pwd) => {
      return function (dispatch, getState, { history }) {
        auth.setPersistence(firebase.auth.Auth.Persistence.SESSION).then((res) => {
          auth
            .signInWithEmailAndPassword(id, pwd)
            .then((user) => {
              console.log(user);

              dispatch(
                setUser({
                  user_name: user.user.displayName,
                  id: id,
                  user_profile: "",
                  uid: user.user.uid,
                })
              );

              history.push("/");
            })
            .catch((error) => {
              var errorCode = error.code;
              var errorMessage = error.message;

              console.log(errorCode, errorMessage);
            });
        });
      };
    };

    ...
    ```

- firebase 인증 키를 export 해준다.

    ```tsx
    // src/shared/firebase.js
    export const apiKey = firebaseConfig.apiKey;
    ```

- 세션을 체크해서 로그인 상태를 유지한다.
    - Permit 컴포넌트를 만들어 로그인 시에만 보이도록 할 수 있다.

    ```tsx
    // src/shared/Permit.js
    import React from "react";
    import {useSelector} from "react-redux";
    import { apiKey } from "./firebase";

    const Permit = (props) => {
        // 유저 정보가 있는 지, 토큰이 있는 지를 체크합니다!
        const user_info = useSelector(state => state.user.user);

        const _session_key = `firebase:authUser:${apiKey}:[DEFAULT]`;

        // 세션이 있나 확인합니다
        const is_login = sessionStorage.getItem(_session_key);

        if(is_login && user_info){
            return <React.Fragment>{props.children}</React.Fragment>;    
        }

        return null;
    }

    export default Permit;
    ```

    ```jsx
    // src/components/common/Header.js
    ...
    import { apiKey } from "../../shared/firebase";
    ...

    const Header = React.memo((props) => {
     ...
      const _session_key = `firebase:authUser:${apiKey}:[DEFAULT]`;

      // 세션이 있나 확인합니다
      const is_login = sessionStorage.getItem(_session_key);
    ...
    ```

- firebase를 통해 로그인 상태가 맞나 확인하여 유저 정보를 가져다 넣어준다.

    ```jsx
    // user.js
    ...
    const loginCheckFB = () => {
      return function (dispatch, getState, {history}){
        auth.onAuthStateChanged((user) => {
          if(user){
            dispatch(
              setUser({
                user_name: user.displayName,
                user_profile: "",
                id: user.email,
                uid: user.uid,
              })
            );
          }else{
            dispatch(logOut());
          }
        })
      }
    }
    ...
    ```

    ```jsx
    // App.js
    ...
    function App() {
      const dispatch = useDispatch();

      const _session_key = `firebase:authUser:${apiKey}:[DEFAULT]`;
      const is_session = sessionStorage.getItem(_session_key)? true : false;
      
      React.useEffect(() => {
        
        if(is_session){
          dispatch(userActions.loginCheckFB());
        }

      }, []);

      return (
        <React.Fragment>
          <Grid>
            <Header></Header>
            <ConnectedRouter history={history}>
              <Route path="/" exact component={PostList} />
              <Route path="/login" exact component={Login} />
              <Route path="/signup" exact component={Signup} />
            </ConnectedRouter>
          </Grid>
        </React.Fragment>
      );
    }

    export default App;
    ```

## 포스트 목록 가져오기

- 리덕스 모듈 만들기
    - redux-actions, immer 라이브러리 가져오기

        → `createAction`, `handleActions` 함수

        → `produce` 함수

    - 필요한 액션 만들어주기

        : `createAction` 을 이용하여 액션 크리에이터 만들기

        ```tsx
        const SET_POST = "SET_POST";
        const setPost = createAction(SET_POST, (post_list) => ({post_list}));
        ```

    - initialState 만들기

        : 동시에 게시글 하나에 대한 더미 데이터도 만들어 놓기

    - 리듀서 작성하기

        ```tsx
        export default handleActions(
          {
              [SET_POST]: (state, action) => produce(state, (draft) => {
                
              }),
          },
          initialState
        );
        ```

    - 액션 크리에이터를 다른 페이지에서 사용 가능하도록 export 하기

        ```tsx
        const actionCreators = {
          setPost,
        };

        export { actionCreators };
        ```

- root 리듀서에 post 리듀서 추가하기
    - 스토어에 히스토리 넣어주기 포함 ([connected-react-router](https://github.com/supasate/connected-react-router))

    ```tsx
    // redux/configureStore.js
    ...
    import { combineReducers } from "redux";
    import Post from "./modules/post";
    import { connectRouter } from "connected-react-router";
    import { createBrowserHistory } from "history"; // react-router
    ...
    export const history = createBrowserHistory();
    const rootReducer = combineReducers({
      post: Post,
      router: connectRouter(history),
    });
    ...
    ```

- 게시글 목록 페이지에 연동하기

    ```tsx
    // pages/PostList.js
    ...
    import {useSelector} from "react-redux";
    ...
    const PostList = (props) => {
    	const post_list = useSelector((state) => state.post.list);
    ...
    ```

- firestore 연동 준비하기
    - firestore에서 post 컬렉션 만들고 더미 데이터 넣기
    - firestore 추가하기

        ```tsx
        // shared/firebase.js
        import "firebase/firestore";
        ...
        const firestore = firebase.firestore();
        ...
        export{ firestore };
        ```

- firestore에서 데이터 가져오기

    ```jsx
    //redux/modules/post.js
    import { firestore } from "../../shared/firebase";
    ...
    const getPostFB = () => {
      return function (dispatch, getState, { history }) {
        const postDB = firestore.collection("post");

        postDB.get().then((docs) => {
          let post_list = [];

          docs.forEach((doc) => {
            // 잘 가져왔나 확인하기! :)
            // 앗! DB에서 가져온 것하고 우리가 Post 컴포넌트에서 쓰는 데이터 모양새가 다르네요!
            // console.log(doc.id, doc.data());

            // 데이터 모양을 맞춰주자!
            let _post = doc.data();
            let post = {
                id: doc.id,
                user_info: {
                    user_name: _post.user_name,
                    user_profile: _post.user_profile,
                    user_id: _post.user_id,
                },
                contents: _post.contents,
                image_url: _post.image_url,
                comment_cnt: _post.comment_cnt,
                imsert_dt: _post.insert_dt
            }

            post_list.push(post);
          });

          // 리스트 확인하기!
          console.log(post_list);

          dispatch(setPost(post_list));
        });
      };
    };
    ```

- 게시글 목록 컴포넌트(페이지)에서 호출하기

    ```jsx
    // PostList.js
    import React from "react";

    import Post from "../components/Post";
    import {useSelector, useDispatch} from "react-redux";
    import {actionCreators as postActions} from "../redux/modules/post";

    const PostList = (props) => {
        const dispatch = useDispatch();
        const post_list = useSelector((state) => state.post.list);

        console.log(post_list);

        React.useEffect(() => {
            dispatch(postActions.getPostFB());

        }, []);

        return (
            <React.Fragment>
                {post_list.map((p, idx) => {

                    return <Post key={p.id} {...p}/>
                })}
            </React.Fragment>
        )
    }

    export default PostList;
    ```

## 포스트 작성하기

👉 포스트 작성 후 목록 페이지로 되돌아 왔을 때, 목록을 파이어스토어로 가져올 필요 없이 그냥 추가한 데이터만 리덕스에 추가해주면 요청을 하나 덜 보낼 수 있다는 점!

- 로그인 여부 체크하기

    ```jsx
    // pages/PostWrite.js
    ...
    const PostWrite = (props) => {
      const is_login = useSelector((state) => state.user.is_login);
      const {history} = props;
      console.log(is_login);

      if(!is_login){
        return (
          <Grid margin="100px 0px" padding="16px" center>
            <Text size="32px" bold>
              앗! 잠깐!
            </Text>
            <Text size="16px">
              로그인 후에만 글을 쓸 수 있어요!
            </Text>
            <Button
              _onClick={() => {
                history.replace("/login");
              }}
            >
              로그인 하러가기
            </Button>
          </Grid>
        );
      }
    ...
    ```

- 작성 페이지로 이동하기

    ```jsx
    // shared/App.js
    ...
    <Permit>
        <Button is_float text="+" _onClick={() => {history.push('/write');}}></Button>
    </Permit>
    ...
    ```

- firestore에 저장하는 함수 만들기

    ```jsx
    // redux/modules/post.js
    import moment from "moment";
    ...
    const initialPost = {
      image_url: "https://mean0images.s3.ap-northeast-2.amazonaws.com/4.jpeg",
      contents: "",
      comment_cnt: 0,
      insert_dt: moment().format("YYYY-MM-DD hh:mm:ss"),
    };
    ...
    const addPostFB = (contents = "") => {
      return function (dispatch, getState, { history }) {
        const postDB = firestore.collection("post");

        const _user = getState().user.user;
        const user_info = {
          user_name: _user.user_name,
          user_id: _user.uid,
          user_profile: _user.user_profile,
        };

        const _post = {
          ...initialPost,
          contents: contents,
          insert_dt: moment().format("YYYY-MM-DD hh:mm:ss")
        };
        // 잘 만들어졌나 확인해보세요!!
        console.log(_post);

        postDB.add({...user_info, ..._post}).then((doc) => {
            // 아이디를 추가해요!
            let post = {user_info, ..._post, id: doc.id};
    				console.log(post);
        }).catch((err) => {
            console.log('post 작성 실패!', err);
        });
      };
    };
    ```

- 작성 버튼과 연동하기

    ```jsx
    // pages/PostWrite.js
    ...
    import {useSelector, useDispatch} from "react-redux";
    import {actionCreators as postActions} from "../redux/modules/post";

    const PostWrite = (props) => {
      const dispatch = useDispatch();
     ...
      
      const addPost = () => {
        dispatch(postActions.addPostFB(contents));
      }
    ...

        return (
    	  ...
            <Grid padding="16px">
              <Button text="게시글 작성" _onClick={addPost}></Button>
            </Grid>
         ...
        );
    }

    export default PostWrite;
    ```

- 저장 성공 시 리덕스에 추가하기

    ```jsx
    // redux/modules/post.js
    const addPostFB = (post, image = null) => {
      ...
    	postDB.add({...user_info, ..._post}).then((doc) => {
            // 아이디를 추가해요!
            let post = {user_info, ..._post, id:doc.id};
            // 이제 리덕스에 넣어봅시다.
            dispatch(addPost(post));
        }).catch((err) => {
            console.log('post 작성 실패!', err);
        });
    ...
    };
    ...
    [ADD_POST]: (state, action) => produce(state, (draft) => {
            // unshift는 배열 맨 앞에 데이터를 넣어줘요!
             draft.list.unshift(action.payload.post);
        }),
    ...
    ```

- 작성 후 페이지로 이동하기

    ```jsx
    	...
    	postDB.add({...user_info, ..._post}).then((doc) => {
            // 아이디를 추가해요!
            let post = {...user_info, ..._post, id: doc.id};
            // 이제 리덕스에 넣어봅시다.
            dispatch(addPost(post));
            history.replace("/");
        }).catch((err) => {
            console.log('post 작성 실패!', err);
        });
    	...
    ```

## 게시글 작성 시 이미지 업로드하기 + 프리뷰 보여주기

- firebase storage 연결하기

    ```jsx
    import firebase from "firebase/app";
    import "firebase/auth";
    import "firebase/firestore";
    import "firebase/storage";

    const firebaseConfig = {
      apiKey: "여러분의 api key를 여기에!",
      ... // 그 외 설정들이 여기에 들어가요! apikey와 함께 넣어주세요!
    };

    firebase.initializeApp(firebaseConfig);

    const apiKey = firebaseConfig.apiKey;
    const auth = firebase.auth();
    const firestore = firebase.firestore();
    const storage = firebase.storage();

    export{auth, apiKey, firestore, storage};
    ```

- firebase 콘솔에서 rules 설정하기

    ```jsx
    // 파이어베이스 콘솔 -> Storage에서 규칙(rules) 탭으로 이동!아래처럼 바꿔주기!
    rules_version = '2';
    service firebase.storage {
      match /b/{bucket}/o {
        match /{allPaths=**} {
    			allow read, write: if request.auth != null;
        }
      }
    }
    ```

- 리덕스에 image 모듈 만들기
    - 필요한 액션 만들기

        → 이미지를 firebase에 올리고, 업로드 성공 시 업로드한 파일의 다운로드 경로를 가져와서 리덕스에 넣어주는 액션

        → 업로드 중에는 파일 선택을 막아주는 액션

    - initialState 만들기
    - 리듀서 작성하기
    - 액션 크리에이터를 다른 페이지에서 사용 가능하도록 export 하기

    ```tsx
    import { createAction, handleActions } from "redux-actions";
    import produce from "immer";

    import { storage } from "../../shared/firebase";

    // actions
    const UPLOADING = "UPLOADING";
    const UPLOAD_IMAGE = "UPLOAD_IMAGE";

    // action creators
    const uploading = createAction(UPLOADING, (uploading) => ({ uploading }));
    const uploadImage = createAction(UPLOAD_IMAGE, (image_url) => ({ image_url }));

    function uploadImageFB(image) {
      return function (dispatch, getState, {history}) {
        
        dispatch(uploading(true));
        
        console.log(`images/${new Date().getTime()}_${image.name}`);
        const _upload = storage.ref(`images/${image.name}`).put(image);

        //   업로드!
        _upload.then((snapshot) => {
          console.log(snapshot);

          // 업로드한 파일의 다운로드 경로를 가져오자!
          snapshot.ref.getDownloadURL().then((url) => {
            console.log(url);
            dispatch(uploadImage(url));
          });
        }).catch(err => {
            dispatch(uploading(false));
        });
      };
    }

    // initial state
    const initialState = {
      image_url: "http://via.placeholder.com/400x300",
      uploading: false,
    };

    // reducer
    export default handleActions(
      {
        [UPLOAD_IMAGE]: (state, action) =>
          produce(state, (draft) => {
            draft.image_url = action.payload.image_url;
            draft.uploading = false;
          }),

        [UPLOADING]: (state, action) =>
          produce(state, (draft) => {
            draft.uploading = action.payload.uploading;
          }),
      },
      initialState
    );

    const actionCreators = {
      uploadImage,
      uploadImageFB,
    };

    export { actionCreators };
    ```

- root 리듀서에 image 리듀서 추가하기

    ```jsx
    // src/redux/configureStore.js
    ...
    import Image from "./modules/image";
    ...

    const rootReducer = combineReducers({
      user: User,
      post: Post,
      image:Image,
      router: connectRouter(history),
    });
    ```

- 이미지 업로드 해보기

    `<input type="file"/>`은 파일 선택 시 `onChange` 이벤트에 선택한 파일이 객체로 넘어온다.

    유저가 `input`으로 내 컴퓨터로부터 업로드할 파일을 선택하면, 인풋 태그는 `FileList`라는 객체에 파일을 담아 보관한다.

    `FileList`에 있는 파일 하나 하나는 `File` 객체이며, 이 `File` 객체를 사용해서 firebase의 storage에 파일을 업로드한다.

    ```jsx
    import React from "react";
    import { useDispatch, useSelector } from "react-redux";
    import { Button } from "../elements";

    import { actionCreators as imageActions } from "../redux/modules/image";

    const Upload = (props) => {
      const dispatch = useDispatch();
      const uploading = useSelector((state) => state.image.uploading);
      const fileInput = React.useRef();

      const selectFile = (e) => {
        // e.target은 input이죠!
        // input이 가진 files 객체를 살펴봅시다.
        console.log(e.target.files);
        // 선택한 파일이 어떻게 저장되어 있나 봅시다.
        console.log(e.target.files[0]);

        // ref로도 확인해봅시다. :)
        console.log(fileInput.current.files[0]);
      };

      const uploadFB = () => {
        if (!fileInput.current || fileInput.current.files.length === 0) {
          window.alert("파일을 선택해주세요!");
          return;
        }

        dispatch(imageActions.uploadImageFB(fileInput.current.files[0]));
      };

      return (
        <React.Fragment>
          <input
            type="file"
            ref={fileInput}
            onChange={selectFile}
            disabled={uploading}
          />
          <Button _onClick={uploadFB}>업로드하기</Button>
        </React.Fragment>
      );
    };

    export default Upload;
    ```

- 프리뷰 만들기

    게시글 올리기 전까지 미리보기를 못하면 불편하므로 이미지 선택 시 선택한 이미지를 사용자가 볼 수 있도록 한다.

    storage에 업로드 하고 보여줘도 되지만 선택한 파일의 경로를 가져오는 방식이 여기서는 좀 더 효율적이다.

    File 객체는 [FileReader](https://developer.mozilla.org/ko/docs/Web/API/FileReader)로 읽어올 수 있다.

    ```jsx
    // shared/Upload.js

    const selectFile = (e) => {
        // e.target은 input이죠!
        // input이 가진 files 객체를 살펴봅시다.
        console.log(e.target.files);
        // 선택한 파일이 어떻게 저장되어 있나 봅시다.
        console.log(e.target.files[0]);

        // ref로도 확인해봅시다. :)
        console.log(fileInput.current.files[0]);

        const reader = new FileReader();
        const file = e.target.files[0];

        // 파일 내용을 읽어옵니다.
        reader.readAsDataURL(file);

        // 읽기가 끝나면 발생하는 이벤트 핸들러예요! :)
        reader.onloadend = () => {
          // reader.result는 파일의 컨텐츠(내용물)입니다!
          console.log(reader.result);
        };
      };
    ```

- 리덕스 image 모듈에 액션, initialState, 리듀서 업데이트하기

    ```jsx
    // actions
    const UPLOADING = "UPLOADING";
    const UPLOAD_IMAGE = "UPLOAD_IMAGE";
    const SET_PREVIEW = "SET_PREVIEW";

    // action creators
    const uploading = createAction(UPLOADING, (uploading) => ({ uploading }));
    const uploadImage = createAction(UPLOAD_IMAGE, (image_url) => ({ image_url }));
    const setPreview = createAction(SET_PREVIEW, (preview) => ({ preview }));

    const initialState = {
      image_url: "",
      uploading: false,
      preview: null,
    };

    export default handleActions(
      {
        [UPLOAD_IMAGE]: (state, action) =>
          produce(state, (draft) => {
            draft.image_url = action.payload.image_url;
            draft.uploading = false;
          }),

        [UPLOADING]: (state, action) =>
          produce(state, (draft) => {
            draft.uploading = action.payload.uploading;
          }),

        [SET_PREVIEW]: (state, action) =>
          produce(state, (draft) => {
            draft.preview = action.payload.preview;
          }),
      },
      initialState
    );

    const actionCreators = {
      uploadImage,
      uploadImageFB,
      setPreview,
    };
    ```

- 미리보기 이미지 컴포넌트 추가하기

    ```jsx
    // pages/PostWrite.js
    ...

    const PostWrite = (props) => {
      const dispatch = useDispatch();
      const is_login = useSelector((state) => state.user.is_login);
      const preview = useSelector((state) => state.image.preview);
      
    	...
        return (
          <React.Fragment>
    				...
              <Image
                shape="rectangle"
                src={preview ? preview : "http://via.placeholder.com/400x300"}
              />
            ...
          </React.Fragment>
        );
    }

    export default PostWrite;
    ```

- Upload.js Input 컴포넌트에서 액션 dispatch 하기

    ```jsx
    // shared/Upload.js
    const selectFile = (e) => {
        // e.target은 input이죠!
        // input이 가진 files 객체를 살펴봅시다.
        console.log(e.target.files);
        // 선택한 파일이 어떻게 저장되어 있나 봅시다.
        console.log(e.target.files[0]);

        // ref로도 확인해봅시다. :)
        console.log(fileInput.current.files[0]);

        const reader = new FileReader();
        const file = e.target.files[0];

        // 파일 내용을 읽어옵니다.
        reader.readAsDataURL(file);

        // 읽기가 끝나면 발생하는 이벤트 핸들러예요! :)
        reader.onloadend = () => {
          // reader.result는 파일의 컨텐츠(내용물)입니다!
          console.log(reader.result);
          dispatch(imageActions.setPreview(reader.result));
        };
      };
    ```

- 게시글 작성 시 preview 가져오기

    ```jsx
    const addPostFB = (contents = "") => {
      return function (dispatch, getState, { history }) {
        ...
    		// getState()로 store의 상태값에 접근할 수 있어요!
        const _image = getState().image.preview;

    		// post.js에서 확인해봐요!
    		console.log(typeof _image);
    		...
      };
    };
    ```

- data_url로 파일 업로드하기

    [해당 공식문서](https://firebase.google.com/docs/storage/web/upload-files?authuser=0)

    게시글을 작성하기 전에 이미지를 먼저 업로드하고 성공했을 때만 firestore에 게시글을 저장하게 한다.

    ```tsx
    ...
    import {actionCreators as imageActions} from "./image";
    ...
    const addPostFB = (contents = "") => {
      return function (dispatch, getState, { history }) {
        const postDB = firestore.collection("post");

        const _user = getState().user.user;
        const user_info = {
          user_name: _user.user_name,
          user_id: _user.uid,
          user_profile: _user.user_profile,
        };

        const _post = {
          ...initialPost,
          contents: contents,
          insert_dt: moment().format("YYYY-MM-DD hh:mm:ss"),
        };

        // 잘 만들어졌나 확인해보세요!!
        console.log(_post);

        // getState()로 store의 상태값에 접근할 수 있어요!
        const _image = getState().image.preview;

        // 데이터가 어떤 타입인지 확인해봐요!
        console.log(typeof _image);

        // 파일 이름은 유저의 id와 현재 시간을 밀리초로 넣어줍시다! (혹시라도 중복이 생기지 않도록요!)
        const _upload = storage
          .ref(`images/${user_info.user_id}_${new Date().getTime()}`)
          .putString(_image, "data_url");

        _upload
          .then((snapshot) => {
            snapshot.ref
              .getDownloadURL()
              .then((url) => {
                // url을 확인해봐요!
                console.log(url);
                dispatch(imageActions.uploadImage(url));
                return url;
              })
              .then((url) => {
                // return으로 넘겨준 값이 잘 넘어왔나요? :)
                // 다시 콘솔로 확인해주기!
                console.log(url);

                postDB
                  .add({ ...user_info, ..._post, image_url: url })
                  .then((doc) => {
                    // 아이디를 추가해요!
                    let post = { user_info, ..._post, id: doc.id, image_url: url };
                    // 이제 리덕스에 넣어봅시다.
                    dispatch(addPost(post));
                    history.replace("/");
                  })
                  .catch((err) => {
    								window.alert("앗! 포스트 작성에 문제가 있어요!");
                    console.log("post 작성 실패!", err);
                  });
              });
          })
          .catch((err) => {
    				window.alert("앗! 이미지 업로드에 문제가 있어요!");
            console.log(err);
          });
      };
    };
    ```

## 이벤트 관리하기

Lodash라는 자바스크립트 유틸리티 라이브러리의 debounce, throttle 기능을 사용하여 이벤트를 관리한다.

Lodash는 그 외에도 배열 관리, 모듈화, 성능 향상과 관련된 것까지 엄청 많은 기능을 제공한다.

### 이벤트가 엄청 많이 일어나는 경우

검색 시 타이핑 할 때마다 검색 API를 호출하는 경우

→ 특정 시간마다 1번씩 호출하거나 키보드 입력을 멈췄을 때만 1번 호출하도록 한다.

- debounce

    이벤트가 일어나면, 일정 시간을 기다렸다가 이벤트를 수행한다. 일정 시간 내에 같은 이벤트가 또 들어오면 이전 요청은 취소한다.

    ```jsx
    // shared/Search.js
    import React from "react";
    import _ from "lodash"; // lodash 부르기

    const Search = () => {
      const debounce = _.debounce((k) => console.log("디바운스! :::", k), 1000);
      const keyPress = React.useCallback(debounce, []);

      const onChange = (e) => {
        keyPress(e.target.value);
      };

      return (
        <div>
          <label>Search:</label>
          <input onChange={onChange} />
        </div>
      );
    };

    export default Search;
    ```

- throttle

    일정 시간 동안 일어난 이벤트를 모아서 주기적으로 1번씩 실행한다.

    ```jsx
    // shared/Search.js
    import React from "react";
    import _ from "lodash"; // lodash 부르기

    const Search = () => {
      const throttle = _.throttle((k) => console.log("쓰로틀! :::", k), 1000);
      const keyPress = React.useCallback(throttle, []);

      const onChange = (e) => {
        keyPress(e.target.value);
      };

      return (
        <div>
          <label>Search:</label>
          <input onChange={onChange} />
        </div>
      );
    };

    export default Search;
    ```

## 무한 스크롤

게시글을 한번에 많이 가져오면 페이지 로드 속도가 느려지기 때문에 페이징 처리가 필요하다.

- initialState에 추가하기

    throttle은 요청을 여러 번 보낼 수 있기 때문에 is_loading이라는 판별자가 하나 더 필요하다.

    ```jsx
    const initialState = {
      list: [],
      paging: { start: null, next: null, size: 3 },
      is_loading: false,
    };
    ```

- firebase에서 페이징대로 데이터 가져오게 하기

    ```jsx
    const getPostFB = (start = null, size=3) => {
      return function (dispatch, getState, { history }) {

        // state에서 페이징 정보 가져오기
        let _paging = getState().post.paging;

        // 시작정보가 기록되었는데 다음 가져올 데이터가 없다면? 앗, 리스트가 끝났겠네요!
        // 그럼 아무것도 하지말고 return을 해야죠!
        if (_paging.start && !_paging.next) {
          return;
        }
        
        // 가져오기 시작~!
        dispatch(loading(true));
        
        const postDB = firestore.collection("post");

        let query = postDB.orderBy("insert_dt", "desc");

        // 시작점 정보가 있으면? 시작점부터 가져오도록 쿼리 수정!
        if(start){
          query = query.startAt(start);
        }

        // 사이즈보다 1개 더 크게 가져옵시다. 
        // 3개씩 끊어서 보여준다고 할 때, 4개를 가져올 수 있으면? 앗 다음 페이지가 있겠네하고 알 수 있으니까요.
        // 만약 4개 미만이라면? 다음 페이지는 없겠죠! :)
        query.limit(size+1).get().then((docs) => {
          let post_list = [];

          // 새롭게 페이징 정보를 만들어줘요.
          // 시작점에는 새로 가져온 정보의 시작점을 넣고,
          // next에는 마지막 항목을 넣습니다.
          // (이 next가 다음번 리스트 호출 때 start 파라미터로 넘어올거예요.)
          let paging = {
            start: docs.docs[0],
            next: docs.docs.length === size+1? docs.docs[docs.docs.length - 1] : null,
            size: size,
          };

          docs.forEach((doc) => {
            let _post = doc.data();

            let post = Object.keys(_post).reduce(
              (acc, cur) => {
                if (cur.indexOf("user_") !== -1) {
                  return {
                    ...acc,
                    user_info: { ...acc.user_info, [cur]: _post[cur] },
                  };
                }
                return { ...acc, [cur]: _post[cur] };
              },
              { id: doc.id, user_info: {} }
            );

            post_list.push(post);
          });

          // 마지막 하나는 빼줍니다.
          // 그래야 size대로 리스트가 추가되니까요!
          // 마지막 데이터는 다음 페이지의 유무를 알려주기 위한 친구일 뿐! 리스트에 들어가지 않아요!
          post_list.pop();

          dispatch(setPost(post_list, paging));
        });
      };
    };
    ```

- 리덕스에서도 기존 리스트에 추가되도록 리듀서 수정하기

    ```jsx
    [SET_POST]: (state, action) =>
          produce(state, (draft) => {
            draft.list.push(...action.payload.post_list);
            draft.paging = action.payload.paging;
            draft.is_loading = false;
          }),
    ```

- 게시글 목록 페이지에 적용하기

    ```jsx
    // PostList.js
    import React from "react";

    import Post from "../components/Post";
    import { useSelector, useDispatch } from "react-redux";
    import { actionCreators as postActions } from "../redux/modules/post";

    const PostList = (props) => {
      const dispatch = useDispatch();
      const post_list = useSelector((state) => state.post.list);
      const user_info = useSelector((state) => state.user.user);
      const is_loading = useSelector((state) => state.post.is_loading);
      const paging = useSelector((state) => state.post.paging);

      React.useEffect(() => {
        if(post_list.length === 0){
            dispatch(postActions.getPostFB());
        }
      }, []);

      return (
        <React.Fragment>
          
            {post_list.map((p, idx) => {
              if (user_info && p.user_info.user_id === user_info.uid) {
                return <Post key={p.id} {...p} is_me />;
              }
              return <Post key={p.id} {...p} />;
            })}
         
        </React.Fragment>
      );
    };

    export default PostList;
    ```

- InfinityScroll 컴포넌트 만들기

    InfinityScroll이 작용해야 하는 범위를 생각해본다.

    ```jsx
    import React from "react";

    import Spinner from "../elements/Spinner";
    import _ from "lodash";

    const InfinityScroll = (props) => {
      const { children, callNext, is_next, loading } = props;

      // 쓰로틀을 적용합시다!
      const _handleScroll = _.throttle(() => {
          callNext();
        }
      }, 300);

      const handleScroll = React.useCallback(_handleScroll, [loading]);

      React.useEffect(() => {
        // 로딩 중이면, return!
        if (loading) {
          return;
        }

        // 다음 게 있으면 이벤트를 붙이고, 없으면 이벤트를 삭제해요!
        if (is_next) {
          window.addEventListener("scroll", handleScroll);
        } else {
          window.removeEventListener("scroll", handleScroll);
        }

        // 이 부분은 컴포넌트가 사라질 때 호출되는 부분입니다! (클린업이라고도 해요.)
        return () => window.removeEventListener("scroll", handleScroll);
      }, [is_next, loading]);

      return (
        <React.Fragment>
          {children}
    			{is_next && <Spinner />}
        </React.Fragment>
      );
    };

    InfinityScroll.defaultProps = {
      children: null,
      callNext: () => {},
      is_next: false,
      loading: false,
    };

    export default InfinityScroll;
    ```

- 게시글 목록 페이지에 적용하기

    ```jsx
    // PostList.js
    import React from "react";

    import Post from "../components/Post";
    import { useSelector, useDispatch } from "react-redux";
    import { actionCreators as postActions } from "../redux/modules/post";
    import InfinityScroll from "../shared/InfinityScroll";

    const PostList = (props) => {
      const dispatch = useDispatch();
      const post_list = useSelector((state) => state.post.list);
      const user_info = useSelector((state) => state.user.user);
      const is_loading = useSelector((state) => state.post.is_loading);
      const paging = useSelector((state) => state.post.paging);

      React.useEffect(() => {
        if(post_list.length === 0){
            dispatch(postActions.getPostFB());
        }
      }, []);

      return (
        <React.Fragment>
          <InfinityScroll
            callNext={() => {
              console.log("next!");
    					dispatch(postActions.getPostFB(paging.next));
            }}
            is_next={paging.next? true : false}
            loading={is_loading}
          >
            {post_list.map((p, idx) => {
              if (user_info && p.user_info.user_id === user_info.uid) {
                return <Post key={p.id} {...p} is_me />;
              }
              return <Post key={p.id} {...p} />;
            })}
          </InfinityScroll>
        </React.Fragment>
      );
    };

    export default PostList;
    ```

- 스크롤 계산하기

    **window.innerHeight : 가시적으로 보이는 브라우저 창 높이**

    **document.body.scrollHeight : 스크롤 할 수 있는 높이**

    **document.documentElement.scrollTop : 스크롤이 얼마나 움직였는지 알려주는 값**

    ```jsx
    const _handleScroll = _.throttle(() => {
        const { innerHeight } = window;
        const { scrollHeight } = document.body;

        // 스크롤 계산!
        const scrollTop =
          (document.documentElement && document.documentElement.scrollTop) ||
          document.body.scrollTop;

        if (scrollHeight - innerHeight - scrollTop < 200) {
          // 로딩 중이면 다음 걸 부르면 안되겠죠!
          if (loading) {
            return;
          }

          callNext();
        }
      }, 300);
    ```

- 스피너 붙이기

    ```jsx
    import React from "react";
    import styled from "styled-components";

    const Spinner = (props) => {
      const { type, size, is_dim } = props;

      return (
        <React.Fragment>
          <SpinnerWrap type={type} is_dim={is_dim}>
            <SpinnerSvg size={size} />
          </SpinnerWrap>
        </React.Fragment>
      );
    };

    Spinner.defaultProps = {
      type: "inline", // inline, page
      is_dim: false,
      size: 60,
    };

    const SpinnerWrap = styled.div`
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px 0;
      ${(props) =>
        props.type === "page"
          ? `position: fixed;
            height: 95vh;
            top: 0;
            left: 0;
            padding: 0;
            zIndex: 9999;`
          : ``}
      ${(props) =>
        props.is_dim
          ? `
         background: rgba(0,0,0,0.4); 
         height: 100vh;
      `
          : ``}
    `;

    const SpinnerSvg = styled.div`
      --size: ${(props) => props.size}px;
      width: var(--size);
      height: var(--size);
      background-image: url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' style='margin: auto; background: none; display: block; shape-rendering: auto;' width='200px' height='200px' viewBox='0 0 100 100' preserveAspectRatio='xMidYMid'%3E%3Cg transform='rotate(0 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.9166666666666666s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(30 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.8333333333333334s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(60 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.75s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(90 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.6666666666666666s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(120 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.5833333333333334s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(150 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.5s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(180 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.4166666666666667s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(210 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.3333333333333333s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(240 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.25s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(270 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.16666666666666666s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(300 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='-0.08333333333333333s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3Cg transform='rotate(330 50 50)'%3E%3Crect x='47' y='24' rx='3' ry='3.36' width='6' height='12' fill='%23222222'%3E%3Canimate attributeName='opacity' values='1;0' keyTimes='0;1' dur='1s' begin='0s' repeatCount='indefinite'%3E%3C/animate%3E%3C/rect%3E%3C/g%3E%3C/svg%3E\");
      background-size: var(--size);
    `;

    export default Spinner;
    ```

## 상세 페이지 연결하기

- 게시글 목록 페이지에서 onClick 넘겨주고, Grid 컴포넌트에서 실행하기

    ```jsx
    // PostList.js
    import React from "react";
    import {useSelector, useDispatch} from "react-redux";

    import Post from "../components/Post";
    import {actionCreators as postActions} from "../redux/modules/post";
    import InfinityScroll from "../shared/InfinityScroll";
    import {Grid} from "../elements";

    const PostList = (props) => {
        const dispatch = useDispatch();
        const post_list = useSelector((state) => state.post.list);
        const user_info = useSelector((state) => state.user.user);
        const is_loading = useSelector((state) => state.post.is_loading);
        const paging = useSelector((state) => state.post.paging);

        const {history} = props;
        
        React.useEffect(() => {

            if(post_list.length === 0){
                 dispatch(postActions.getPostFB());
            }
           
        }, []);

        return (
          <React.Fragment>
            <Grid bg={"#EFF6FF"} padding="20px 0px">
              {/* <Post/> */}
              <InfinityScroll
                callNext={() => {
                  dispatch(postActions.getPostFB(paging.next));
                }}
                is_next={paging.next ? true : false}
                loading={is_loading}
              >
                {post_list.map((p, idx) => {
                  if (p.user_info.user_id === user_info?.uid) {
                    return (
                      <Grid
                        bg="#ffffff"
                        margin="8px 0px"
                        key={p.id}
                        _onClick={() => {
                          history.push(`/post/${p.id}`);
                        }}
                      >
                        <Post key={p.id} {...p} is_me />
                      </Grid>
                    );
                  } else {
                    return (
                      <Grid
    										key={p.id}
                        bg="#ffffff"
                        _onClick={() => {
                          history.push(`/post/${p.id}`);
                        }}
                      >
                        <Post {...p} />
                      </Grid>
                    );
                  }
                })}
              </InfinityScroll>
            </Grid>
          </React.Fragment>
        );
    }

    export default PostList;
    ```

- 리덕스에서 데이터 가져오기

    해당 게시글 id를 이용해서 리덕스로부터 게시글 정보 하나만 가져온다.

    ```jsx
    import React from "react";
    import Post from "../components/Post";
    import CommentList from "../components/CommentList";
    import CommentWrite from "../components/CommentWrite";

    import {useSelector} from "react-redux";

    const PostDetail = (props) => {
        const id = props.match.params.id;

        const user_info = useSelector((state) => state.user.user);

        const post_list = useSelector(store => store.post.list);
        
        const post_idx = post_list.findIndex(p => p.id === id);
        const post = post_list[post_idx];

        return (
            <React.Fragment>
                <Post {...post} is_me={post.user_info.user_id === user_info.uid}/>
                <CommentWrite/>
                <CommentList/>
            </React.Fragment>
        )
    }

    export default PostDetail;
    ```

- 리덕스에 데이터가 없는 경우, firestore로부터 단일 게시글을 가져오기

    ```jsx
    import React from "react";
    import Post from "../components/Post";
    import CommentList from "../components/CommentList";
    import CommentWrite from "../components/CommentWrite";

    import {useSelector} from "react-redux";

    import {firestore} from "../shared/firebase";

    const PostDetail = (props) => {
        const id = props.match.params.id;

        const user_info = useSelector((state) => state.user.user);

        const post_list = useSelector(store => store.post.list);
        
        const post_idx = post_list.findIndex(p => p.id === id);
        const post_data = post_list[post_idx];

        const [post, setPost] = React.useState(post_data? post_data : null);

        React.useEffect(() => {

            if(post){
               return; 
            }
            
            const postDB = firestore.collection("post");
            postDB.doc(id).get().then(doc => {
                console.log(doc);
                console.log(doc.data());
                
                let _post = doc.data();
                let post = Object.keys(_post).reduce(
                  (acc, cur) => {
                    if (cur.indexOf("user_") !== -1) {
                      return {
                        ...acc,
                        user_info: { ...acc.user_info, [cur]: _post[cur] },
                      };
                    }
                    return { ...acc, [cur]: _post[cur] };
                  },
                  { id: doc.id, user_info: {} }
                );

                setPost(post);
            })

        }, []);

        return (
          <React.Fragment>
            {post && (
              <Post {...post} is_me={post.user_info.user_id === user_info.uid} />
            )}
            <CommentWrite />
            <CommentList />
          </React.Fragment>
        );
    }

    export default PostDetail;
    ```

## 댓글 가져오기

- firestore에 댓글 컬렉션(/comment) 만들기
    - contents, insert_dt, post_id, user_id, user_name, user_profile 넣기
    - 복합 쿼리를 사용하기 위해 색인 추가 (설정하고 반영되기까지 시간 소요)
- 리덕스 모듈 만들기
    - import, 액션 타입, 액션 생성자, initialState, 리듀서, export
    - 루트 리듀서에 추가까지 하기

    ```tsx
    // redux/modules/comment.js

    import { createAction, handleActions } from "redux-actions";
    import { produce } from "immer";
    import { firestore } from "../../shared/firebase";
    import "moment";
    import moment from "moment";

    const SET_COMMENT = "SET_COMMENT";
    const ADD_COMMENT = "ADD_COMMENT";

    const LOADING = "LOADING";

    const setComment = createAction(SET_COMMENT, (post_id, comment_list) => ({post_id, comment_list}));
    const addComment = createAction(ADD_COMMENT, (post_id, comment) => ({post_id, comment}));

    const loading = createAction(LOADING, (is_loading) => ({ is_loading }));

    const initialState = {
      list: {},
      is_loading: false,
    };

    const getCommentFB = (post_id) => {
        return function(dispatch, getState, {history}){

        }
    }

    export default handleActions(
      {
          [SET_COMMENT]: (state, action) => produce(state, (draft) => {

          }),
          [ADD_COMMENT]: (state, action) => produce(state, (draft)=> {

          }),
          [LOADING]: (state, action) => 
          produce(state, (draft) => {
            draft.is_loading = action.payload.is_loading;
          })
      },
      initialState
    );

    const actionCreators = {
      getCommentFB,
      setComment,
      addComment,
    };

    export { actionCreators };
    ```

- 게시글 상세 페이지 고치기

    firestore 데이터를 리덕스에 넣어두도록 수정한다.

    → `redux/modules/post.js` 에서 게시글 하나 정보 가져오는 함수 만들기

    ```jsx
    ...
    const getOnePostFB = (id) => {
      return function(dispatch, getState, {history}){
        const postDB = firestore.collection("post");
        postDB
          .doc(id)
          .get()
          .then((doc) => {
            let _post = doc.data();

            if (!_post) {
              return;
            }

            let post = Object.keys(_post).reduce(
              (acc, cur) => {
                if (cur.indexOf("user_") !== -1) {
                  return {
                    ...acc,
                    user_info: { ...acc.user_info, [cur]: _post[cur] },
                  };
                }
                return { ...acc, [cur]: _post[cur] };
              },
              { id: doc.id, user_info: {} }
            );

            dispatch(setPost([post], { start: null, next: null, size: 3 }));
          });
      }
    }
    ...

    export default handleActions(
      {
       [SET_POST]: (state, action) =>
          produce(state, (draft) => {

            draft.list.push(...action.payload.post_list);

            // post_id가 같은 중복 항목을 제거합시다! :)
            draft.list = draft.list.reduce((acc, cur) => {
              // findIndex로 누산값(cur)에 현재값이 이미 들어있나 확인해요!
              // 있으면? 덮어쓰고, 없으면? 넣어주기!
              if (acc.findIndex((a) => a.id === cur.id) === -1){
                return [...acc, cur];
              }else{
                acc[acc.findIndex((a) => a.id === cur.id)] = cur;
                return acc;
              }
            }, []);

    				// paging이 있을 때만 넣기
            if (action.payload.paging) {
              draft.paging = action.payload.paging;
            }
            draft.is_loading = false;
          }),
       ...
      },
      initialState
    );

    const actionCreators = {
      setPost,
      addPost,
      editPost,
      getPostFB,
      addPostFB,
      editPostFB,
      getOnePostFB,
    };
    ...
    ```

- 게시글 상세 페이지에 적용하기

    ```jsx
    import React from "react";
    import Post from "../components/Post";
    import CommentList from "../components/CommentList";
    import CommentWrite from "../components/CommentWrite";

    import { useSelector, useDispatch } from "react-redux";

    import {actionCreators as postActions} from "../redux/modules/post";

    const PostDetail = (props) => {
      const dispatch = useDispatch();
      const id = props.match.params.id;

      const user_info = useSelector((state) => state.user.user);

      const post_list = useSelector((store) => store.post.list);

      const post_idx = post_list.findIndex((p) => p.id === id);
      const post = post_list[post_idx];

      React.useEffect(() => {
        if (post) {
          return;
        }

        dispatch(postActions.getOnePostFB(id));
      }, []);

      return (
        <React.Fragment>
          {post && (
            <Post {...post} is_me={post.user_info.user_id === user_info?.uid} />
          )}
          <CommentWrite post_id={id} />
          <CommentList post_id={id} />
        </React.Fragment>
      );
    };

    export default PostDetail;
    ```

- 게시글 목록 페이지 첫 진입 시, 데이터 가져오는 조건 바꿔주기

    ```jsx
    // pages/PostList.js
    ...
    React.useEffect(() => {
    // 가지고 있는 데이터가 0개, 1개일 때만 새로 데이터를 호출해요.
        if (post_list.length < 2) {
          dispatch(postActions.getPostFB());
        }
      }, []);
    ...
    ```

- 게시글 id, 작성 일시 역순으로 정렬해서 댓글 가져오기

    ```jsx
    const getCommentFB = (post_id = null) => {
      return function (dispatch, getState, { history }) {
        const commentDB = firestore.collection("comment");
    		
    		// post_id가 없으면 바로 리턴하기!
        if(!post_id){
            return;
        }

        // where로 게시글 id가 같은 걸 찾고,
        // orderBy로 정렬해줍니다.
        commentDB
          .where("post_id", "==", post_id)
          .orderBy("insert_dt", "desc")
          .get()
          .then((docs) => {
            let list = [];
            docs.forEach((doc) => {
              list.push({ ...doc.data(), id: doc.id });
            });
            //   가져온 데이터를 넣어주자!
            dispatch(setComment(post_id, list));
          }).catch(err => {
              console.log("댓글 가져오기 실패!", post_id, err);
          });
      };
    };
    ```

- 리듀서 작성하기

    ```jsx
    [SET_COMMENT]: (state, action) =>
          produce(state, (draft) => {
            // comment는 딕셔너리 구조로 만들어서,
            // post_id로 나눠 보관합시다! (각각 게시글 방을 만들어준다고 생각하면 구조 이해가 쉬워요.)
            draft.list[action.payload.post_id] = action.payload.comment_list;
          }),
    ```

- CommentList에서 부르기

    ```jsx
    // components/CommentList.js
    import React from "react";
    import {Grid, Image, Text} from "../elements";

    import {useDispatch, useSelector} from "react-redux";
    import {actionCreators as commentActions} from "../redux/modules/comment";

    const CommentList = (props) => {
      const dispatch = useDispatch();
      const comment_list = useSelector(state => state.comment.list);
      
      const {post_id} = props;

      React.useEffect(() => {
        if(!comment_list[post_id]){
          // 코멘트 정보가 없으면 불러오기
          dispatch(commentActions.getCommentFB(post_id));
        }
      }, []);

      // comment가 없거나, post_id가 없으면 아무것도 안넘겨준다!
      if(!comment_list[post_id] || !post_id){
        return null;
      }

      return (
        <React.Fragment>
          <Grid padding="16px">
            {comment_list[post_id].map(c => {
              return (<CommentItem key={c.id} {...c}/>);
            })}
          </Grid>
        </React.Fragment>
      );
    };

    CommentList.defaultProps = {
      post_id: null
    };

    export default CommentList;

    const CommentItem = (props) => {

        const {user_profile, user_name, user_id, post_id, contents, insert_dt} = props;
        return (
            <Grid is_flex>
                <Grid is_flex width="auto">
                    <Image shape="circle"/>
                    <Text bold>{user_name}</Text>
                </Grid>
                <Grid is_flex margin="0px 4px">
                    <Text margin="0px">{contents}</Text>
                    <Text margin="0px">{insert_dt}</Text>
                </Grid>
            </Grid>
        )
    }

    CommentItem.defaultProps = {
        user_profile: "",
        user_name: "mean0",
        user_id: "",
        post_id: 1,
        contents: "귀여운 고양이네요!",
        insert_dt: '2021-01-01 19:00:00'
    }
    ```

## 댓글 작성하기

- 댓글 입력하면 내용 가져오기

    ```jsx
    // components/CommentWrite.js
    import React from "react";
    import Post from "../components/Post";
    import CommentList from "../components/CommentList";
    import CommentWrite from "../components/CommentWrite";

    import { useSelector } from "react-redux";

    import { firestore } from "../shared/firebase";

    const PostDetail = (props) => {
     ...
      const [contents, setContents] = React.useState("");
     ...
      

      const write = () => {
          if(contents === ""){
              window.alert("댓글을 입력해주세요!");
            return;
          }
    			console.log(comment_text);
      }

      return (
        <React.Fragment>
          {post && (
            <Post {...post} is_me={post.user_info.user_id === user_info.uid} />
          )}
          <CommentWrite
            _onChange={(e) => {
              setContents(e.target.value);
            }}
            _onClick={write}
          />
          <CommentList />
        </React.Fragment>
      );
    };

    export default PostDetail;
    ```

- firebase에 댓글 정보 추가한 뒤 해당 게시글에도 댓글 갯수 업데이트하기

    ```jsx
    const addCommentFB = (post_id, contents) => {
      return function (dispatch, getState, { history }) {
        const commentDB = firestore.collection("comment");
        const user_info = getState().user.user;

        let comment = {
          post_id: post_id,
          user_id: user_info.uid,
          user_name: user_info.user_name,
          user_profile: user_info.user_profile,
          contents: contents,
          insert_dt: moment().format("YYYY-MM-DD hh:mm:ss"),
        };

        // firestore에 코멘트 정보를 넣어요!
        commentDB.add(comment).then((doc) => {
          const postDB = firestore.collection("post");
          comment = { ...comment, id: doc.id };

          const post = getState().post.list.find((l) => l.id === post_id);

          //   firestore에 저장된 값을 +1해줍니다!
          const increment = firebase.firestore.FieldValue.increment(1);
          
          // post에도 comment_cnt를 하나 플러스 해줍니다.
          postDB
            .doc(post_id)
            .update({ comment_cnt: increment })
            .then((_post) => {
              dispatch(addComment(post_id, comment));
              // 리덕스에 post가 있을 때만 post의 comment_cnt를 +1해줍니다.
              if (post) {
                dispatch(
                  postActions.editPost(post_id, {
                    comment_cnt: parseInt(post.comment_cnt) + 1,
                  })
                );
              }
            });
        });
      };
    };
    ```

- 리듀서 작성하기

    ```jsx
    [ADD_COMMENT]: (state, action) => produce(state, (draft) => {
            draft.list[action.payload.post_id].push(action.payload.comment);
        }),
    ```

- 댓글 작성 컴포넌트에서 부르기

    ```jsx
    //components/CommentWrite.js
    import React from "react";

    import { Grid, Input, Button } from "../elements";

    import { useDispatch } from "react-redux";
    import { actionCreators as commentActions } from "../redux/modules/comment";

    const CommentWrite = (props) => {
      const dispatch = useDispatch();

      const { post_id } = props;

      const [comment_text, setCommentText] = React.useState("");

      const write = () => {
        if (comment_text === "") {
          window.alert("댓글을 입력해주세요!");
          return;
        }
        // 입력된 텍스트는 지우기!
        setCommentText("");

        // 파이어스토어에 추가합니다.
        dispatch(commentActions.addCommentFB(post_id, comment_text));
      };

      return (
        <React.Fragment>
          <Grid padding="16px" is_flex>
            <Input
              placeholder="댓글 내용을 입력해주세요 :)"
              _onChange={onChange}
              value={comment_text}
              onSubmit={write}
              is_submit
            />
            <Button width="50px" margin="0px 2px 0px 2px" _onClick={write}>
              작성
            </Button>
          </Grid>
        </React.Fragment>
      );
    };

    CommentWrite.defaultProps = {
      post_id: "",
    };

    export default CommentWrite;
    ```

- 엔터 키 입력 시 댓글이 입력되도록 만들기

    onKeyPress 이벤트를 이용해서 엔터 키를 감지하면 된다.

    ```tsx
    // elements/Input.js

    import React from "react";
    import styled from "styled-components";

    import { Text, Grid } from "./index";

    const Input = (props) => {
      const {
        label,
        placeholder,
        _onChange,
        type,
        multiLine,
        value,
        is_submit,
        onSubmit,
      } = props;

      if (multiLine) {
        return (
          <Grid>
            {label && <Text margin="0px">{label}</Text>}
            <ElTextarea
              rows={10}
              value={value}
              placeholder={placeholder}
              onChange={_onChange}
            ></ElTextarea>
          </Grid>
        );
      }

      return (
        <React.Fragment>
          <Grid>
            {label && <Text margin="0px">{label}</Text>}
            {is_submit ? (
              <ElInput
                type={type}
                placeholder={placeholder}
                onChange={_onChange}
                value={value}
                onKeyPress={(e) => {
                  if(e.key === "Enter"){
                    onSubmit(e);
                  }
                }}
              />
            ) : (
              <ElInput type={type} placeholder={placeholder} onChange={_onChange} />
            )}
          </Grid>
        </React.Fragment>
      );
    };

    Input.defaultProps = {
      multiLine: false,
      label: false,
      placeholder: "텍스트를 입력해주세요.",
      type: "text",
      value: "",
      is_submit: false,
      onSubmit: () => {},
      _onChange: () => {},
    };

    const ElTextarea = styled.textarea`
      border: 1px solid #212121;
      width: 100%;
      padding: 12px 4px;
      box-sizing: border-box;
    `;

    const ElInput = styled.input`
      border: 1px solid #212121;
      width: 100%;
      padding: 12px 4px;
      box-sizing: border-box;
    `;

    export default Input;
    ```

## 댓글 알림 뱃지 만들기

내가 쓴 게시글에 내가 아닌 사람이 댓글을 쓰면 알려준다.

알림을 읽었는지에 대한 구분자가 있어야 한다.

- firebase의 realtime database 추가하기

    ```jsx
    // shared/firebase.js

    import firebase from "firebase/app";
    import "firebase/auth";
    import "firebase/firestore";
    import "firebase/storage";
    import "firebase/database";

    const firebaseConfig = {
      //인증정보!
    };

    firebase.initializeApp(firebaseConfig);

    const apiKey = firebaseConfig.apiKey;
    const auth = firebase.auth();
    const firestore = firebase.firestore();
    const storage = firebase.storage();
    const realtime = firebase.database();

    export{auth, apiKey, firestore, storage, realtime};
    ```

- realtime database 리스너 구독하기

    ```jsx
    import React from "react";
    import { Badge } from "@material-ui/core";
    import NotificationsIcon from "@material-ui/icons/Notifications";

    import {realtime} from "../shared/firebase";
    import {useSelector} from "react-redux";

    const NotiBadge = (props) => {
      const [is_read, setIsRead] = React.useState(true);
      const user_id = useSelector(state => state.user.user.uid);
      const notiCheck = () => {
          props._onClick();
      };

      React.useEffect(() => {
        const notiDB = realtime.ref(`noti/${user_id}`);

        notiDB.on("value", (snapshot) => {
            console.log(snapshot.val());
            
            setIsRead(snapshot.val().read);
        });
      }, []);

      return (
        <React.Fragment>
          <Badge color="secondary" variant="dot" invisible={is_read} onClick={notiCheck}>
            <NotificationsIcon />
          </Badge>
        </React.Fragment>
      );
    };

    NotiBadge.defaultProps = {
      _onClick: () => {},
    };

    export default NotiBadge;
    ```

- 구독 해제도 추가하기

    ```jsx
    React.useEffect(() => {
       ...
        // 리스너를 해제합시다!
        return () => notiDB.off();
      }, []);
    ```

- 헤더 구현하기

    ```jsx
    ...
    import NotiBadge from "./NotiBadge";

    const Header = (props) => {
    ...
      if (is_login && is_session) {
        return (
          <React.Fragment>
            <Grid is_flex padding="4px 16px">
              <Grid>
                <Text margin="0px" size="24px" bold>
                  헬로
                </Text>
              </Grid>

              <Grid is_flex>
                <Button text="내정보"></Button>
                <NotiBadge _onClick={() => {
                  history.push("/noti");
                }}/>
                <Button
                  text="로그아웃"
                  _onClick={() => {
                    dispatch(userActions.logoutFB());
                  }}
                ></Button>
              </Grid>
            </Grid>
          </React.Fragment>
        );
      }
    ...
    ```

- 댓글 달았을 때 알림 주기

    ```jsx
    // redux/modules/comment.js

    const addCommentFB = (post_id, contents) => {
      return function (dispatch, getState, { history }) {
        const commentDB = firestore.collection("comment");
        const user_info = getState().user.user;

        let comment = {
          post_id: post_id,
          user_id: user_info.uid,
          user_name: user_info.user_name,
          user_profile: user_info.user_profile,
          contents: contents,
          insert_dt: moment().format("YYYY-MM-DD hh:mm:ss"),
        };

        // firestore에 코멘트 정보를 넣어요!
        commentDB.add(comment).then((doc) => {
          const postDB = firestore.collection("post");
          comment = { ...comment, id: doc.id };

          // post 정보 가져오기!
          const post = getState().post.list.find((l) => l.id === post_id);

          //   firestore에 저장된 값을 +1해줍니다!
          const increment = firebase.firestore.FieldValue.increment(1);

          // post에도 comment_cnt를 하나 플러스 해줍니다.
          postDB
            .doc(post_id)
            .update({ comment_cnt: increment })
            .then((_post) => {
              // comment를 추가해주고,
              dispatch(addComment(post_id, comment));

              // 리덕스에 post가 있을 때만 post의 comment_cnt를 +1해줍니다.
              if (post) {
                dispatch(
                  postActions.editPost(post_id, {
                    comment_cnt: parseInt(post.comment_cnt) + 1,
                  })
                );
                
                // 알림이 가게 해줍니다!
                const notiDB = realtime.ref(`noti/${post.user_info.user_id}`);
                // 읽음 상태를 false로 바꿔주면 되겠죠!
                notiDB.update({ read: false});
              }
            });
        });
      };
    };
    ```

- 노티 아이콘 누르면 읽음 처리하기

    ```jsx
    // components/NotiBadge.js
    	const notiCheck = () => {
        notiDB.update({ read: true });
        props._onClick();
      };
    ```

- 알림 페이지 구현하기

    알림 내역에는 댓글을 쓴 유저의 user_name, post_id, image_url, insert_dt가 필요하다.

    ```jsx
    // redux/modules/comment.js
    const addCommentFB = (post_id, contents) => {
      return function (dispatch, getState, { history }) {
        ...

          // post에도 comment_cnt를 하나 플러스 해줍니다.
          postDB
            .doc(post_id)
            .update({ comment_cnt: increment })
            .then((_post) => {
              // comment를 추가해주고,
              dispatch(addComment(post_id, comment));

              // 리덕스에 post가 있을 때만 post의 comment_cnt를 +1해줍니다.
              if (post) {
                dispatch(
                  postActions.editPost(post_id, {
                    comment_cnt: parseInt(post.comment_cnt) + 1,
                  })
                );

                // 알림 리스트에 하나를 추가해줍니다!
                const _noti_item = realtime
                  .ref(`noti/${post.user_info.user_id}/list`)
                  .push();

                _noti_item.set({
                  post_id: post.id,
                  user_name: comment.user_name,
                  image_url: post.image_url,
                  insert_dt: comment.insert_dt
                }, (err) => {
                    if(err){
                        console.log('알림 저장 실패');
                    }else{
                      // 알림이 가게 해줍니다!
                      const notiDB = realtime.ref(`noti/${post.user_info.user_id}`);
                      // 읽음 상태를 false로 바꿔주면 되겠죠!
                      notiDB.update({ read: false });
                    }
                });
              }
            });
        });
      };
    };
    ```

- 알림 페이지에서 가져오기

    ```jsx
    // pages/Notification.js
    import React from "react";
    import {Grid} from "../elements";
    import Card from "../components/Card";

    import {realtime} from "../shared/firebase";
    import {useSelector} from "react-redux";

    const Notification = (props) => {
      const [noti, setNoti] = React.useState([]);

        const user = useSelector(state => state.user.user);

        React.useEffect(() => {

          if(!user){
            return;
          }

          const notiDB = realtime.ref(`noti/${user.uid}/list`);
          
          // firebase realtime database는 내림차순 정렬을 지원하지 않아요!
          // 데이터를 가져온 후 직접 역순으로 내보내야 합니다!
          const _noti = notiDB.orderByChild("insert_dt");
          
          _noti.once('value', snapshot => {
            
            if(snapshot.exists()){
              let _data = snapshot.val();

              // reserse()는 배열을 역순으로 뒤집어줘요.
              let _noti_list = Object.keys(_data).reverse().map(s => {
                return _data[s];
              });

              setNoti(_noti_list);
            }
            
          })
        }, [user]);

        return (
          <React.Fragment>
            <Grid padding="16px" bg="#EFF6FF">
              {noti.map((n, idx) => {
                return <Card {...n} key={`noti_${idx}`} />;
              })}
            </Grid>
          </React.Fragment>
        );
    }

    export default Notification;
    ```

- 알림을 누르면 포스트 페이지로 이동하기

    ```jsx
    // components/Card.js

    import React from "react";
    import { Grid, Text, Image } from "../elements";

    import {history} from "../redux/configureStore";

    const Card = (props) => {
      const { image_url, user_name, post_id } = props;

      return (
        <Grid
          padding="16px"
          is_flex
          bg="#ffffff"
          margin="8px 0px"
          _onClick={() => {history.push(`/post/${post_id}`);}}
        >
          <Grid width="auto" margin="0px 8px 0px 0px">
            <Image src={image_url} size={85} shape="square" />
          </Grid>
          <Grid>
            <Text>
              <b>{user_name}</b>님이 게시글에 댓글을 남겼습니다 :)!{" "}
            </Text>
          </Grid>
        </Grid>
      );
    };

    Card.defaultProps = {
      image_url: "http://via.placeholder.com/400x300",
    };

    export default Card;
    ```

## SEO

검색 엔진에서 검색 시 내가 만든 웹사이트가 검색 결과에 더 잘보이게 하기 위한 과정이다.

검색 엔진이 내 사이트의 html을 한 번 훑어가고(크롤링), 특정한 인덱스를 생성하여 검색 결과에 보여준다.

리액트는 html 파일이 1개 뿐인 데다가 렌더링 되기 전까지는 빈 껍데기이기 때문에 기본적으로 검색 엔진에 올라가기 어렵다. 따라서 검색 엔진이 긁어갈 수 있도록 미리 html 파일 내용을 보여주는 작업을 해주어야 한다.

검색 엔진마다 크롤링하는 방식이 다 다르기 때문에 우리가 어떤 검색 엔진에 노출되고 싶은 지를 결정하고, 해당 검색 엔진이 제공하는 SEO 가이드에 맞춰서 어떤 방법을 사용할 지 정하는 것이 좋다.

- meta-data 넣기 : 웹페이지의 제목이나 이미지, 간단한 설명을 검색엔진에 알려주는 역할

    ```tsx
    yarn add react-helmet
    ```

    - helmat으로 메타 태그 바꾸기 → 빌드 후 Postman에서 확인하기

        ```tsx
        //One.js
        import React from "react";
        import {Helmet} from "react-helmet";
        const One = (props) => {
            return (
              <div>
                <Helmet>
                  <title>page one</title>
                  <meta property="og:title" content="page one" />
                  <meta property="og:description" content="hi there :) page one" />
                  <meta property="og:image" content="%PUBLIC_URL%/logo192.png" />
                </Helmet>
                <h2>Hi, there :) ! page one</h2>
                <button
                  onClick={() => {
                    props.history.push("/");
                  }}
                >
                  page one
                </button>
                <button
                  onClick={() => {
                    props.history.push("/two");
                  }}
                >
                  page two
                </button>
              </div>
            );
        }

        export default One;
        ```

- pre-rendering
- SSR

## Pre-rendering

빌드 시 html 파일을 미리 만들어 두는 것 → [react-snap](https://github.com/stereobooster/react-snap) 사용

- 테스트용 One, Two 페이지 만들고, 라우트 적용하기

hydrate : 정적으로 렌더링 된 html 컨텐츠가 정적으로 동작할 수 있도록 이벤트를 보충해주는 역할

- hydrate 사용하기

    ```jsx
    import React from 'react';
    import ReactDOM, { hydrate } from "react-dom";
    ...

    const root = document.getElementById("root");

    if (root.hasChildNodes()) {
      hydrate(
          <App />,
        root
      );
    } else {
      ReactDOM.render(
        <App />,
        root
      );
    }
    ...
    ```

- package.json의 scripts에서 postbuild 추가해주기

    ```jsx
    ...
    "scripts": {
        "start": "react-scripts start",
        "build": "react-scripts build",
        "test": "react-scripts test",
        "eject": "react-scripts eject",
        "postbuild": "react-snap"
      },
    ...
    "reactSnap": {
        "include": [
          "/two",
          "/"
        ]
      },
    ...
    ```

- 빌드한 프로젝트를 로컬에서 실행해보기

    ```tsx
    // serve.json
    {
      "rewrites": [
        { "source": "/", "destination": "/200.html" },
        { "source": "/two", "destination": "/two/index.html" }
      ]
    }
    ```

    ```tsx
    #한줄씩 입력해주세요 :)
    yarn global add serve

    serve -c serve.json build
    ```

- html에 내용물이 들어오는지 Postman으로 확인하기

## 성능 지표 보기

"webVitals"로 웹사이트 성능 체크가 가능하다.

- firebase analytics 연결하기
    - analytics 연결하기

        ```jsx
        ...
        import "firebase/analytics";

        const firebaseConfig = {
          // 인증 정보!
        };
        ...

        const analytics = firebase.analytics();

        export{auth, apiKey, firestore, storage, realtime, analytics};
        ```

    - 리포트 보내기

        ```jsx
        //index.js
        ...
        import { analytics } from "./shared/firebase";
        ...
        function sendToAnalytics(metric) {
          const _report = JSON.stringify(metric);

          analytics.logEvent("web_vital_report", _report);

          console.log({ _report });
        }
        reportWebVitals(sendToAnalytics);
        ```

    - 확인하기

        대시보드에서 확인해볼까요! 🙂 

        ![%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA%E1%84%87%E1%85%A1%E1%86%AB%203919ac1335334519a0da4373744db222/_2021-03-23__9.41.03.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%92%E1%85%AA%E1%84%87%E1%85%A1%E1%86%AB%203919ac1335334519a0da4373744db222/_2021-03-23__9.41.03.png)

## 렌더링 횟수 줄이기

컴포넌트를 렌더링하고, 결과를 메모이제이션해두어 부모 컴포넌트가 바뀔 때마다 바뀔 게 없는 컴포넌트까지 다시 렌더링하는 걸 막아줄 수 있다.

```tsx
// components/Post.js

import React from "react";
import { Grid, Image, Text, Button } from "../elements";

import {history} from "../redux/configureStore";

 const Post = React.memo((props) => {
   console.log("in post");
   return (
     <React.Fragment>
       ...
     </React.Fragment>
   );
 });
...
```

## 개선하기

### 성능 최적화

- 사이트 로딩 속도 개선하기
    - ttfb 측정하기
    - 렌더링 횟수 줄이기
    - 자바스크립트 번들 사이즈를 줄이기 (code splitting)
- 중복 호출 방지하기(동일한 요청이 여러 번 일어나지 않도록)
    - loading이 true면 버튼을 disable하거나, api 요청을 못하게 막는다.
- 이미지 용량 줄이기
    - 사용하는 곳에 맞게 이미지 리사이징해서 저장하기
    - .webp로 확장자를 바꾸어 저장하기
- css로 이미지 스프라이트 하기
    - 작은 조각 이미지들을 한 군데 몰아서 만들고, css로 쪼개서 쓰기

        → background-position, background-image 속성을 이용

### 사용성 끌어올리기

우리가 만든 사이트를 쉽게 쓰도록 만든다.

- 이미지 지연 로딩
    - 이미지가 100% 로딩되기 전까지는 흐릿한 이미지나 특정 색만 보여주다가 완전히 로드되면 갈아끼운다.
- 스피너 달기
    - 사이트를 다시 그리는 과정에서 텅 빈 화면이나 아직 데이터가 없어서 미운 화면을 가릴 수 있다.

        → [react-placeholder](https://github.com/buildo/react-placeholder)

- 오류 페이지 만들기
- 벨리데이션 체크 미리 하기
    - 잘못된 데이터를 넘겨주지 않도록 한다.