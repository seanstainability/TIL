# 리액트 기본반

## 웹의 동작

우리가 웹사이트를 보는 도구를 모두 "클라이언트"라 하고, "서버"는 웹사이트에 뿌려줄 HTML이나 데이터를 만들어서 클라이언트에 전달해준다.

### HTML을 받는 경우

API 라는 창구로 요청을 보내고,

서버에서 미리 준비해두었던 HTML 파일을 "받아서", "그려주는" 것이다.

### 데이터만 받는 경우

페이지를 리프레시하지 않고, 데이터만 받아서 끼운다.

데이터는 주로 JSON 형식이다.

### 서버리스

서버가 없다는 게 아니라 서버를 내가 만들 필요가 없다는 것이다.

설정이 미리 되어 있는 서버를 빌려다 쓰는 것이다.

## 자바스크립트 기초

### 클래스

특정 객체를 생성하기 위해 상태(변수)와 함수를 정의하는 일종의 틀

생성자 함수는 생성한 인스턴스를 초기화(초기값 설정)하는 역할이다.

재사용성이 높다.

### 변수와 스코프

스코프는 변수에 접근할 수 있는 범위를 말한다.

var은 함수 단위, let과 const는 block 단위 스코프를 가진다.

### Spread 연산자

어떤 객체 안에 있는 요소들을 객체 바깥으로 전부 꺼내준다.

### Array 내장 함수

앞으로 설명하는 내장 함수들은 모두 새로운 배열로 만들어주기 때문에 원본 배열은 바뀌지 않는다.

1. map : 배열에 속한 항목을 원하는 대로 "변환할 때" 사용
2. filter : 어떤 조건을 만족하는 항목들만 "고를 때" 사용
3. concat : 배열과 배열을 "합치거나" 배열에 특정 값을 "추가할 때" 사용

    : concat은 중복 항목을 제거해주지는 않는다.

    : Set을 사용하면 중복되지 않는 값을 가지는 리스트를 만들 수 있다.

4. from : 유사배열을 복사해서 "새로운 배열"로 만들 때 많이 사용

    : 유사 배열이랑 배열 모양으로 생겼지만 배열의 내장 함수를 사용하지 못하는 배열

5. reduce : ?
6. indexOf("문자열") : 파라미터로 넘겨준 문자열이 몇 번째 위치에 있는지 알려준다.

## 준비하기

### NVM

```tsx
nvm install [설치할 버전]
nvm ls # nvm으로 설치한 노드 버전 리스트 확인 명령어
nvm use [사용할 노드 버전]
```

### NPM, Yarn

프론트엔드 의존성을 관리하기 위한 패키지 매니저

```tsx
yarn add [옵션(global...)] [설치할 패키지 이름]
```

### CRA(Create React App)

웹사이트를 만들 때 필요한 것을 몽땅 때려넣어 만든 패키지

```tsx
yarn create react-app [우리의 첫 리액트 프로젝트 이름]
cd [우리의 첫 리액트 프로젝트 이름] # [우리의 첫 리액트 프로젝트 이름] 폴더로 이동합니다.
yarn start
```

### JSX

리액트에서는 딱 하나의 html 파일만 존재한다. (public/index.html)

JSX 문법으로 리액트 요소를 만들고 DOM에 렌더링 시켜서 뷰를 그린다.

컴포넌트에서 반환할 수 있는 엘리먼트는 1개다.

JSX에서 자바스크립트 문법을 사용하려면 {}를 이용한다.

인라인으로 스타일을 줄 때는 CSS 문법 대신 JSON 형식으로 넣어준다.

### Component

클래스형과 함수형이 있다.

리액트를 "레고"라고 하면 컴포넌트는 "블록"에 해당한다.

블록 단위로 잘 조각낼 줄 아는 사람이 리액트를 잘 쓰는 사람이다.

state는 컴포넌트가 가지고 있는 데이터이다. (내꺼)

props는 컴포넌트가 부모 컴포넌트로부터 받아온 데이터이다. (남의꺼)

### SCSS

```tsx
yarn add node-sass@4.14.1 open-color sass-loader classnames
```

### styled-components

컴포넌트에 스타일을 직접 입히는 방식

웹에서 애니메이션을 구현할 때는 transition, animation 스타일 속성을 많이 사용한다. transition은 단순한 엘리먼트 상태 변화, animation은 다이나믹한 효과를 주는 데 사용한다.

keyframes는 animation에서 사용하는 속성 중 하나로, styled-components 안에 이미 들어있다.

CSS에서는 이런 식으로 keyframes를 쓴다.

```tsx
.box {
 width: 100px;
 height: 100px;
 background: #444;
}
.box.active {
 animation: boxFade 2s 1s infinite linear alternate;
}
@keyframes boxFade {
 0% {
  opacity: 1;
 }
 50% {
  opacity: 0;
 }
 100% {
  opacity: 1;
 }
```

- styled-components의 keyframes 사용해보기

```tsx
...
const Box = styled.div`
  width: 100px;
  height: 100px;
  border-radius: 50px;
  background: green;
  position: absolute;
  top: 20px;
  left: 20px;
  animation: ${boxFade} 2s 1s infinite linear alternate;
`;

// 이런식으로 동시에 여러가지 애니메이션을 넣어줄 수 있어요!
const boxFade = keyframes`
  0% {
    opacity: 1;
    top: 20px;

  }
  50% {
    opacity: 0;
    top: 400px;
  }
  100% {
    opacity: 1;
    top: 20px;
  }
`;
...
```

- 버킷리스트에 프로그래스 바 달기

```tsx
const Progress = (props) => {
  // 스토어에서 상태값 가져오기
  const bucket_list = useSelector((state) => state.bucket.list);

  let count = 0;

  let goal_per = bucket_list.map((l, idx) => {
    if(l.completed){
        count++;
    }
  });

  return (
    <ProgressBar>
      <HighLight width={(count / bucket_list.length) * 100 + "%"}></HighLight>
    </ProgressBar>
  );
};

const ProgressBar = styled.div`
  background: #eee;
  width: 100%;
  height: 40px;
`;

const HighLight = styled.div`
  background: orange;
  width: ${(props) => props.width}; // styled-components에서 변수 받아오기
  height: 40px;
`;
```

### 라이프 사이클

DOM은 트리구조의, html 단위 하나하나를 객체로 생각하는 모델이다.

가상돔은 메모리 상에서 돌아가는 가짜 DOM으로, 기존 DOM과 어떤 행동 후 새로 그린 DOM을 비교해서 정말 바뀐 부분만 갈아끼워준다.

state나 props가 바뀌거나, 부모 컴포넌트가 업데이트 되었을 때, 또는 강제로 업데이트 했을 경우(forceUpdate())에 업데이트가 발생한다.

- render() : 컴포넌트의 모양을 정의
- componentDidMount() : 컴포넌트가 화면에 나타나는 것을 마운트(Mount)라고 하며, 첫 렌더링을 마친 후에 딱 한 번 실행된다.
- componentDidUpdate(prevProps, prevState, snapshot) : 리렌더링을 완료한 후 실행되는 함수, 업데이트 되기 전 props와 state를 가져다 사용할 수 있다.
- componentWillUnmount() : 컴포넌트가 DOM에서 제거될 때 실행하는 함수

### React에서 DOM 요소 가져오기

→ `React.createRef()`

### State

단방향 데이터 흐름이다. 즉, 부모에서 자식으로 넘겨줘야 한다.

`setState()` , `useState()`

### Event Listener

DOM 요소가 생겨난 다음에 이벤트 리스너를 달아주고(componentDidMount()), 컴포넌트가 사라지면 꼭 지워준다(componentWillUnmount()).

### SPA

서버에서 주는 html이 1개 뿐인 애플리케이션

전통적인 웹사이트는 페이지를 이동할 때마다 서버에서 정적 자원들을 내려준다면, SPA는 딱 한번만 정적자원을 받아온다.

굳이 html을 하나만 주는 이유는 페이지를 이동할 때마다 화면을 바꾸다보면 상태 유지가 어렵고, 바뀌지 않는 부분까지 새로 불러오기 때문에 비효율적이기 때문이다.

SPA는 처음 한 번에 모든 컴포넌트를 받아오니까 첫 로딩 속도가 느리다.

### 라우팅

브라우저 주소에 따라 다른 페이지를 보여주는 것

```tsx
yarn add react-router-dom
```

- BrowserRouter는 브라우저가 가지고 있는 주소 관련 정보를 props로 넘겨준다.
- 넘겨 줄 props가 없을 때

```tsx
<Route path="주소[/home 처럼 /와 주소를 적어요]" exact component={[보여줄 컴포넌트]}/>
```

- 넘겨 줄 props가 있을 때

```tsx
<Route path="주소[/home 처럼 /와 주소를 적어요]" exact render={(props) => (<BucketList list={this.state.list} />)} />
```

- URL 파라미터 사용하기 : /cat/nabi (쿼리는 /cat?name=nabi 형태)

```tsx
// 파라미터 주기
<Route path="/cat/:cat_name" component={Cat}/>
```

```tsx
//Cat.js
const Cat = (props) => {

    console.log(props.match);

    return (
        <div>고양이 화면이에요.</div>
    )
}
```

- Link 사용하기

```tsx
<Link to="주소">[텍스트]</Link>
```

- history 사용하기 : history 객체를 props로 받아오려면, withRouter를 설정해줘야 한다.

```tsx
import { withRouter } from "react-router";

// 내보내는 부분에서 withRouter로 감싸줍니다
export default withRouter(App);
```

```tsx
        <button onClick={() => {
          // props에 있는 history를 사용합니다.
          // push([이동할 주소])는 페이지를 이동시켜 줍니다.
          this.props.history.push('/cat');
        }}>
          /cat으로 가기
        </button>
        <button onClick={()=>{
          // goBack()은 뒤로가기 예요.
          this.props.history.goBack();
        }}>뒤로가기
        </button>
```

- 잘못된 주소 처리하기 : NotFound 컴포넌트 만들고, Switch와 함께 Route에 주소 없이 연결하면 된다.

```tsx
...
					<Switch>
            <Route
              path="/"
              exact
              render={(props) => (
                <BucketList
                  list={this.state.list}
                  history={this.props.history}
                />
              )}
            />
            <Route path="/detail" component={Detail} />
            <Route component={NotFound} />
          </Switch>
...
```

- 뒤로가기

```tsx
<Route render={(props) => (
                <NotFound
                  history={this.props.history}
                />
              )}/>
```

```tsx
<button onClick={() => {props.history.goBack();}}>뒤로가기</button>
```

- 상세 페이지를 위해 URL 파라미터 적용해보기

```tsx
//App.js
...
					<Switch>
            <Route
              path="/detail/:index"
              render={(props) => <Detail match={props.match} history={props.history} />}
            />
          </Switch>
...
```

```tsx
//BucketList.js
...
      {bucket_list.map((list, index) => {
        return (
          <ItemStyle
            className="list_item"
            key={index}
            onClick={() => {
              // 배열의 몇번째 항목을 눌렀는 지, url 파라미터로 넘겨줍니다.
              props.history.push("/detail/"+index);
            }}
          >
            {list}
          </ItemStyle>
        );
      })}
    </ListStyle>
  );
};
...
```

```tsx
//Detail.js
// 리액트 패키지를 불러옵니다.
import React from "react";

// redux hook을 불러옵니다.
import { useDispatch, useSelector } from "react-redux";

const Detail = (props) => {
  // 스토어에서 상태값 가져오기
  const bucket_list = useSelector((state) => state.bucket.list);
  // url 파라미터에서 인덱스 가져오기
  let bucket_index = parseInt(props.match.params.index);

  return <h1>{bucket_list[bucket_index]}</h1>;
};

export default Detail;
```

### 리덕스

데이터를 한 군데 몰아넣고, 여기저기에서 꺼내볼 수 있게 해준다.

여러 컴포넌트가 동일한 상태를 보고 있을 때 굉장히 유용하다.

데이터를 관리하는 로직을 컴포넌트에서 빼면, 컴포넌트에서는 뷰만 관리할 수 있으므로 유지보수에 아주 좋다.

리액트와 별도로 사용할 수도 있다.

```tsx
yarn add redux react-redux
```

👉 액션 생성 함수를 부르고 → 액션을 만들면 → 리듀서가 현재 상태와 액션 객체를 받아서 → 새로운 데이터를 만들고 → 리턴해준다.

- store는 1개만 쓴다.
- store의 state는 오직 action으로만 변경 가능하다.

    : 불변성을 유지해주어야 한다. 즉, 허락없이 데이터가 바뀌면 안된다.

- 리듀서는 순수 함수여야 한다.

    : 이전 상태를 건드리지 않고, 매번 새로운 객체를 return해야 한다.

    : 파라미터 외의 값에 의존하지 않아야 한다.

👉 리덕스 스토어를 컴포넌트에 연결하고 → 컴포넌트에서 상태 변화가 필요할 때 액션을 디스패치하면 → 리듀서를 통해 새로운 상태 값을 만들고 → 새 상태 값을 스토어에 저장하면 → 컴포넌트는 새로운 상태값을 받아오고 → 리렌더링된다.

### 덕스(ducks) 구조

보통 리덕스는 모양새대로 action, actionCreator, reducer를 분리해서 작성하지만 덕스 구조는 모양새 대신 기능으로 묶어 작성한다.

### 스토어

- 스토어 생성하기

```tsx
//configStore.js
import { createStore, combineReducers } from "redux";
import bucket from './modules/bucket';
import { createBrowserHistory } from "history";

// 브라우저 히스토리를 만들어줍니다.
export const history = createBrowserHistory();
// root 리듀서를 만들어줍니다.
// 나중에 리듀서를 여러개 만들게 되면 여기에 하나씩 추가해주는 거예요!
const rootReducer = combineReducers({ bucket });

// 스토어를 만듭니다.
const store = createStore(rootReducer);

export default store;
```

- 스토어 연결하기

```tsx
// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import {BrowserRouter} from 'react-router-dom';

// 우리의 버킷리스트에 리덕스를 주입해줄 프로바이더를 불러옵니다!
import { Provider } from "react-redux";
// 연결할 스토어도 가지고 와요.
import store from "./redux/configStore";
ReactDOM.render(
  <Provider store={store}>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </Provider>,
  document.getElementById("root")
);
```

- 클래스형 컴포넌트에서 리덕스 데이터 사용하기
    1. 리덕스 모듈과 connect 함수 불러오기
    2. 상태값을 가져오는 함수, 액션 생성 함수를 부르는 함수 만들기
    3. connect로 컴포넌트와 스토어 엮어주기

```tsx
// 리덕스 스토어와 연결하기 위해 connect라는 친구를 호출할게요!
import {connect} from 'react-redux';
// 리덕스 모듈에서 (bucket 모듈에서) 액션 생성 함수 두개를 가져올게요!
import {loadBucket, createBucket} from './redux/modules/bucket';

// 이 함수는 스토어가 가진 상태값을 props로 받아오기 위한 함수예요.
const mapStateToProps = (state) => ({
  bucket_list: state.bucket.list,
});

// 이 함수는 값을 변화시키기 위한 액션 생성 함수를 props로 받아오기 위한 함수예요.
const mapDispatchToProps = (dispatch) => ({
  load: () => {
    dispatch(loadBucket());
  },
  create: (new_item) => {
    dispatch(createBucket(new_item));
  }
});

class App extends React.Component {

  componentDidMount() {
		// 스토어에 있는 값이 잘 나왔는지 확인하기!
    console.log(this.props);
  }

  addBucketList = () => {
    const new_item = this.text.current.value;
    this.props.create(new_item);
  };
	...
}

// withRouter 적용
// connect로 묶어줬습니다!
export default connect(mapStateToProps, mapDispatchToProps)(withRouter(App));
```

- 함수형 컴포넌트에서 리덕스 데이터 사용하기

```tsx
// redux hook을 불러옵니다.
import {useDispatch, useSelector} from 'react-redux';

const BucketList = (props) => {
  // 버킷리스트를 리덕스 훅으로 가져오기
  const bucket_list = useSelector(state => state.bucket.list);
}

```

### 스크롤바 움직이기

- 위로 가기

```tsx
...
button onClick={() => {
          window.scrollTo({ top: 0, left: 0, behavior: "smooth" });
        }}>위로가기</button>
..
```

### Firebase

BaaS(Backend as a Service)

firestore : NoSQL 클라우드 데이터베이스

→ Collection : 문서(다큐먼트)의 집합, Document : JSON 형식으로 데이터 저장

```tsx
yarn add firebase
```

```tsx
//firebase.js
import firebase from "firebase/app";
import "firebase/firestore";

const firebaseConfig = {
    // firebase 설정과 관련된 개인 정보
};

// firebaseConfig 정보로 firebase 시작
firebase.initializeApp(firebaseConfig);

// firebase의 firestore 인스턴스를 변수에 저장
const firestore = firebase.firestore();

// 필요한 곳에서 사용할 수 있도록 내보내기
export { firestore };
```

- 데이터 추가 : 콜렉션을 찾고 → add

    ```tsx
    bucket.add({ text: "수영 배우기", compeleted: false });
    ```

- 데이터 수정 : 콜렉션을 찾고 → 도큐먼트 id로 set

    ```tsx
    bucket.doc("bucket_item").update({ text: "수영 배우기", compeleted: false });
    ```

- 데이터 삭제 : 콜렉션을 찾고 → 도큐먼트 id로 delete

    ```tsx
    bucket.doc("bucket_item").delete([도큐먼트 ID]);
    ```

### firestore 데이터를 리덕스 스토어에 넣기

firestore에서 데이터를 가져올 때 비동기 통신을 하기 때문에 리덕스에서 비동기 통신을 하기 위해 필요한 미들웨어를 설치해 주어야 한다.

액션 발생 → 미들웨어가 할 일 하기 → 리듀서에서 처리 순서로 진행된다.

```tsx
yarn add redux-thunk
```

```tsx
import { createStore, combineReducers, applyMiddleware, compose } from "redux";
import thunk from "redux-thunk";
import bucket from "./modules/bucket";
import { createBrowserHistory } from "history";

export const history = createBrowserHistory();

const middlewares = [thunk];

const enhancer = applyMiddleware(...middlewares);
const rootReducer = combineReducers({ bucket });
const store = createStore(rootReducer, enhancer);

export default store;
```

redux-thunk로 액션 객체가 아닌 함수를 디스패치할 수 있다.

함수를 디스패치할 때는 해당 함수에서 dispatch와 getState를 파라미터로 받아와야 한다.

지연 함수로, 특정 액션이 발생하기 전에 사전에 어떤 처리를 할 수 있다.

1. 파이어베이스와 통신하는 함수 만들기

    ```tsx
    const bucket_db = firestore.collection("bucket");

    // 파이어베이스랑 통신하는 부분
    export const loadBucketFB = () => {
      return function (dispatch) {
        
        bucket_db.get().then((docs) => {
          let bucket_data = [];
          docs.forEach((doc) => {
            // 도큐먼트 객체를 확인해보자!
            console.log(doc);
            // 도큐먼트 데이터 가져오기
            console.log(doc.data());
            // 도큐먼트 id 가져오기
            console.log(doc.id);

            if(doc.exists){
              bucket_data = [...bucket_data, {id: doc.id, ...doc.data()}];
            }
          });

          console.log(bucket_data);
          // 이제 액션 생성 함수한테 우리가 가져온 데이터를 넘겨줘요! 그러면 끝!
          dispatch(loadBucket(bucket_data));
        });
      };
    };
    ```

2. 리듀서 수정하기

    ```tsx
    case "bucket/LOAD": {
          if(action.bucket.length >0){
            return { list: action.bucket };
          }

          return state;
        }
    ```

3. 불러다 쓰기

    ```tsx
    // App.js
    ...
    // 잠깐!! loadBucketFB를 import해오는 거 잊지말기!
    // load()를 componentDidMount에서 부르면 되겠죠? :)
    const mapDispatchToProps = (dispatch) => ({
      load: () => {
        dispatch(loadBucketFB());
      },
      create: (new_item) => {
        console.log(new_item);
        dispatch(createBucket(new_item));
      }
    });
    ...
    ```

- (2) create에 firestore 적용

    순서는 항상 똑같을 거예요! 
    파이어베이스랑 통신 → 필요하다면 리듀서 고치고 → 불러다 쓰기

    ```jsx
    bucket.add({ text: "수영 배우기", completed: false });
    ```

    - 파이어베이스랑 통신하는 함수 만들고,

        ```jsx
        // 파이어베이스랑 통신하는 부분
        export const addBucketFB = (bucket) => {
          return function (dispatch) {
            console.log(bucket);
            // 생성할 데이터를 미리 만들게요!
            let bucket_data = { text: bucket, completed: false };

            // add()에 데이터를 넘겨줍시다!
            bucket_db
              .add(bucket_data)
              .then((docRef) => {
                // id를 추가한다!
                bucket_data = { ...bucket_data, id: docRef.id };

                console.log(bucket_data);

                // 성공했을 때는? 액션 디스패치!
                dispatch(createBucket(bucket_data));
              })
              .catch((err) => {
                // 여긴 에러가 났을 때 들어오는 구간입니다!
                console.log(err);
                window.alert('오류가 났네요! 나중에 다시 시도해주세요!');
              });
          };
        };
        ```

    - 리듀서를 고쳐요!

        ```jsx
        case "bucket/CREATE": {
              const new_bucket_list = [
                ...state.list,
                action.bucket,
              ];
              return { list: new_bucket_list };
            }
        ```

    - 그 후에는요? 불러다 쓰면 되겠죠!

        ```jsx
        // App.js
        ...
        // 잠깐!! addBucketFB를 import해오는 거 잊지말기!
        const mapDispatchToProps = (dispatch) => ({
          load: () => {
            dispatch(loadBucketFB());
          },
          create: (new_item) => {
            console.log(new_item);
            dispatch(addBucketFB(new_item));
          }
        });
        ...
        ```

- (3) update에 firestore 적용

    순서는 항상 똑같을 거예요! 
    파이어베이스랑 통신 → 필요하다면 리듀서 고치고 → 불러다 쓰기

    ```jsx
    bucket.doc([id]).update({ text: "수영 배우기", completed: false });
    ```

    - 파이어베이스랑 통신하는 함수 만들고,

        ```jsx
        // 파이어베이스랑 통신하는 부분
        export const updateBucketFB = (bucket) => {
          return function (dispatch, getState) {
            // state에 있는 값을 가져옵니다!
            const _bucket_data = getState().bucket.list[bucket];

            // id가 없으면? 바로 끝내버립시다.
            if (!_bucket_data.id) {
              return;
            }

            // 새로운 값을 만들어요!
            let bucket_data = { ..._bucket_data, completed: true };

            bucket_db
              .doc(bucket_data.id)
              .update(bucket_data)
              .then((res) => {
                dispatch(updateBucket(bucket));
              })
              .catch((err) => {
                console.log("err");
              });
          };
        };
        ```

    - 그 후에는요? 불러다 쓰면 되겠죠!

        ```jsx
        // Detail.js
        ...
        // 잠깐!! updateBucketFB를 import해오는 거 잊지말기!
        <button onClick={() => {
                  dispatch(updateBucketFB(bucket_index));
                  props.history.goBack();
              }}>완료하기</button>
        ...
        ```

- (4) delete에 firestore 적용

    순서는 항상 똑같을 거예요! 
    파이어베이스랑 통신 → 필요하다면 리듀서 고치고 → 불러다 쓰기

    ```jsx
    bucket.doc([id]).delete();
    ```

    - 파이어베이스랑 통신하는 함수 만들고,

        ```jsx
        // 파이어베이스랑 통신하는 부분
        export const deleteBucketFB = (bucket) => {
          return function (dispatch, getState) {
            const _bucket_data = getState().bucket.list[bucket];
            // id가 없으면? 바로 끝내버립시다.
            if (!_bucket_data.id) {
              return;
            }
            // 삭제하기
            bucket_db
              .doc(_bucket_data.id)
              .delete()
              .then((res) => {
                dispatch(deleteBucket(bucket));
              })
              .catch((err) => {
                console.log("err");
              });
          };
        };
        ```

    - 그 후에는요? 불러다 쓰면 되겠죠!

        ```jsx
        // Detail.js
        ...
        <button onClick={() => {
                //   dispatch(); <- 괄호안에는 액션 생성 함수가 들어가야겠죠?
                // 예를 들면 이렇게요.
                dispatch(deleteBucketFB(bucket_index));
                props.history.goBack();
              }}>삭제하기</button>
        ...
        ```

### 머테리얼 UI

```tsx
yarn add @material-ui/core @material-ui/icons
```

### 페이지 의도적으로 가리기

- 새로고침 시 파이어스토어의 데이터를 가져오기 전에 리덕스에 넣어둔 데이터를 먼저 보여주는 현상을 방지하고 싶을 때
- 추가, 수정 버튼을 눌렀을 때 여러번 API 호출하는 현상을 방지하고 싶을 때
1. 로딩 스피너 컴포넌트 만들기
2. initialState에 is_loaded 변수 추가하고, firestore에서 데이터를 받아오면 갱신한다.
3. App.js에서 is_loaded 상태에 따른 조건부 렌더링을 한다.

### AWS S3 버킷

S3(Simple Storage Service), 단순 스토리지 서비스

정적 자원을 올리고, 정적 웹 사이트를 호스팅할 수도 있다.

웹 사이트는 서버 측 스크립트 사용 유무를 기준으로 동적, 정적으로 나눠볼 수 있다.

→ 서버 측 스크립트로는 PHP, JSP, ASP 등이 있다.

[설명서](https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/WebsiteHosting.html)

1. 버킷 생성하기
2. 권한 탭에서 정책 생성하기 (상단 ARN 복붙하기)
3. 생성한 정책(JSON)을 정책 편집기에 복붙하기 (ARN 뒤에 꼭 `/*` 써주기)
4. 내 프로젝트 빌드 후 결과물 업로드하기 (폴더 안에 있는 파일만 업로드)
5. 속성 탭에서 정적 웹 사이트 호스팅 설정하기
6. 엔드포인트 주소를 클릭 해 내 사이트에 접속하기
7. (도메인 연결 시) route 53에서 호스팅 영역 생성하기
8. (도메인 연결 시) 네임서버를 도메인을 구매한 곳에서 등록하기
9. (도메인 연결 시) 레코드 생성

### Firebase로 배포하기

1. 대시보드에서 호스팅 신청하기
2. CLI 설치 → firebase에 로그인 → init 실행 → 방향키로 호스팅 선택

    ```tsx
    yarn global firebase-tools

    #웹브라우저가 열리고 내 구글 계정을 물어볼거예요. 로그인해줍니다.
    yarn firebase login
    #로그인 후 init!
    yarn firebase init
    ```

3. firebase.json 확인하기

    ```tsx
    {
      "hosting": {
        "public": "build",
        "ignore": [
          "firebase.json",
          "**/.*",
          "**/node_modules/**"
        ]
      }
    }
    ```

4. 빌드한 결과물 올리기

    ```tsx
    yarn firebase deploy
    ```